<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[【vue源码解析】vue源码中一些不为人知的工具函数]]></title>
      <url>%2F2019%2F%E3%80%90vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91vue%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%80%E4%BA%9B%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.html</url>
      <content type="text"><![CDATA[[TOC] 记录和解读vue源码中一些常用的工具函数，在平常工作中或许可以用到这些巧妙的方法 isDef 判断变量是否已定义123export function isDef (v: any): boolean %checks &#123; return v !== undefined &amp;&amp; v !== null&#125; isPrimitive 判断变量是否是基本类型123456789101112/** * Check if value is primitive. */export function isPrimitive (value: any): boolean %checks &#123; return ( typeof value === &apos;string&apos; || typeof value === &apos;number&apos; || // $flow-disable-line typeof value === &apos;symbol&apos; || typeof value === &apos;boolean&apos; )&#125; isPromise 判断是否是priomise1234567export function isPromise (val: any): boolean &#123; return ( isDef(val) &amp;&amp; typeof val.then === &apos;function&apos; &amp;&amp; typeof val.catch === &apos;function&apos; )&#125; isObject12345678/** * Quick object check - this is primarily used to tell * Objects from primitive values when we know the value * is a JSON-compliant type. */export function isObject (obj: mixed): boolean %checks &#123; return obj !== null &amp;&amp; typeof obj === &apos;object&apos;&#125; hasOwn 判断对象自身是否有某个属性1234567/** * Check whether an object has the property. */const hasOwnProperty = Object.prototype.hasOwnPropertyexport function hasOwn (obj: Object | Array&lt;*&gt;, key: string): boolean &#123; return hasOwnProperty.call(obj, key)&#125; cached ?12345678910/** * Create a cached version of a pure function. */export function cached&lt;F: Function&gt; (fn: F): F &#123; const cache = Object.create(null) return (function cachedFn (str: string) &#123; const hit = cache[str] return hit || (cache[str] = fn(str)) &#125;: any)&#125; camelize 横线风格转驼峰风格12345678/** * Camelize a hyphen-delimited string. * 把test-case形式转成testCase驼峰形式 */const camelizeRE = /-(\w)/gexport const camelize = cached((str: string): string =&gt; &#123; return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : &apos;&apos;)&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【vue源码解析】createElement]]></title>
      <url>%2F2019%2F%E3%80%90vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91createElement.html</url>
      <content type="text"><![CDATA[[TOC] vue render 函数 跟 template 一样都是创建 html 模板的。render 函数即渲染函数，它是个函数，它的参数也是个函数（即 createElement），下面我们重点来说 createElement 。 表层：createElement用法123456render: function (createElement) &#123; // 有时候createElement用h作为别名 return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 子节点数组 ) &#125;, createElement参数接下来你需要熟悉的是如何在 createElement 函数中使用模板中的那些功能。这里是 createElement 接受的参数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// @returns &#123;VNode&#125;createElement( /** 第一个参数： 类型：&#123;String | Object | Function&#125; 说明：【必填项】一个 HTML 标签名、组件选项对象，或者resolve 了上述任何一种的一个async函数。 **/ 'div',------------------------------- /** 第二个参数： 类型：&#123;Object&#125; 说明：【可选】模板中的数据 **/ &#123; // 要创建标签的class，与 `v-bind:class` 的 API 相同，接受一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // 标签的内联样式，与 `v-bind:style` 的 API 相同，接受一个字符串、对象，或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // HTML的attrs attrs: &#123; id: 'foo' &#125;, // 组件的prop props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 组件上的事件监听，不再支持如 `v-on:keyup.enter` 这样的修饰器，需要在处理函数中手动检查 keyCode on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用`vm.$emit` 触发的事件 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令，vue directives可以参考https://www.jianshu.com/p/6a4811eb0efe directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽的格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; 相当于组件上使用slot-scoped scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果创建的组件是个slot，需为插槽指定名称，相当于组件上 slot="name-of-slot" slot: 'name-of-slot', // key: 'myKey', ref: 'myRef', // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，那么 `$refs.myRef` 会变成一个数组。 refInFor: true &#125;,------------------------------- /** 第三个参数： 类型：&#123;String | Array&#125; 说明：【可选】子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”。 **/ [ '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;) ]) 第一个参数：【必填】{String | Object | Function} 要渲染的标签名称 第二个参数：【可选】{Object} 模板中的数据 第三个参数：【可选】子级虚拟节点 (VNodes)，由 createElement() 构建而成，也可以使用字符串来生成“文本虚拟节点” createElement源码解析 首先对createElement函数对参数做一层处理，对参数个数不一致情况做处理，然后调用_createElement函数 123456789101112131415161718192021/** * 返回vnode或者vnode组件的数组数据 */export function createElement ( context: Component, // 上下文this tag: any, // 标签 data: any, // vnode数据 children: any, // 子节点 normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; // 当vnode数据是数组或者基本类型的时候,对参数个数不一致的处理 normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; return _createElement(context, tag, data, children, normalizationType) // 真实调用&#125; _createElement函数： 中先对节点data做判断，如果data是响应式的则报警告并生成一个vnode的注释节点 对children做规范化处理:分children是个二维数组和children多层数组嵌套两种情况，将他们拍平成一个一维数组 创建vnode节点：html标签、组件… _createElement函数全部123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293export function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, // html标签 data?: VNodeData, // vnode数据 children?: any, // 子节点 normalizationType?: number // 子节点规范类型 1 2): VNode | Array&lt;VNode&gt; &#123; if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; // 如果data是响应式的报警告 process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` + 'Always create fresh vnode data objects in each render!', context ) return createEmptyVNode() // 生成一个注释节点 &#125; // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is // component is &#125; if (!tag) &#123; // tag // in case of component :is set to falsy value return createEmptyVNode() &#125; // warn against non-primitive key if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key) ) &#123; if (!__WEEX__ || !('@binding' in data.key)) &#123; warn( 'Avoid using non-primitive value as key, ' + 'use string/number value instead.', context ) &#125; &#125; // support single function children as default scoped slot if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function' ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; // 对children做规范化 if (normalizationType === ALWAYS_NORMALIZE) &#123; // children下有多层嵌套，循环调用拍平成一个一维数组 children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; // 如果children下只有一层数组，将二维数组拍平成一个一维数组 children = simpleNormalizeChildren(children) &#125; // 创建vnode let vnode, ns if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // 是否是html原生的一些保留标签 // platform built-in elements if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn)) &#123; warn( `The .native modifier for v-on is only valid on components but it was used on &lt;$&#123;tag&#125;&gt;.`, context ) &#125; vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; // direct component options / constructor vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; children规范化： simpleNormalizeChildren：场景是render函数是编译生成的， 12345678export function simpleNormalizeChildren (children: any) &#123; for (let i = 0; i &lt; children.length; i++) &#123; if (Array.isArray(children[i])) &#123; return Array.prototype.concat.apply([], children) &#125; &#125; return children&#125; normalizeChildren：场景是render 函数是用户手写的，当 children 只有一个节点的时候，Vue 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点，这种情况下回调用 createTextVNode 创建一个文本节点的 VNode；另一个场景就是当编译 slot、 v-for 的时候回产生嵌套数组的情况，回调用 normalizeArrayChildren 方法。normalizeArrayChildren 接收 2 个参数，children 表示要规范的子节点，nestedIndex 表示嵌套的索引，因为单个 child 可能是一个数组类型。normalizeArrayCHildren 主要的逻辑就是遍历 children，获得单个节点 c，然后对 c 的类型判断: 如果是一个数组类型，则递归调用 normalizeArrayChildren； 如果是基础类型，则通过 createTextVNode 方法转换成 VNode 类型；否则就已经是 VNode 类型了; 如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 场景是render 函数是用户手写的， 当 children 只有一个节点的时候， Vue 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点， * 这种情况下回调用 createTextVNode 创建一个文本节点的 VNode； 另一个场景就是当编译 slot、 v-for 的时候回产生嵌套数组的情况， * 回调用 normalizeArrayChildren 方法。 * @param &#123;*&#125; children 要规范的子节点 * @param &#123;string&#125; [nestedIndex] 嵌套的索引 * @returns &#123;Array&lt;VNode&gt;&#125; 返回拍平的一维数组 */function normalizeArrayChildren (children: any, nestedIndex?: string): Array&lt;VNode&gt; &#123; const res = [] let i, c, lastIndex, last for (i = 0; i &lt; children.length; i++) &#123; c = children[i] // c是单个节点 if (isUndef(c) || typeof c === 'boolean') continue lastIndex = res.length - 1 last = res[lastIndex] // nested if (Array.isArray(c)) &#123; // 如果是一个数组类型，则递归调用 normalizeArrayChildren if (c.length &gt; 0) &#123; c = normalizeArrayChildren(c, `$&#123;nestedIndex || ''&#125;_$&#123;i&#125;`) // merge adjacent text nodes if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) &#123; res[lastIndex] = createTextVNode(last.text + (c[0]: any).text) c.shift() &#125; res.push.apply(res, c) &#125; &#125; else if (isPrimitive(c)) &#123; // 如果是基础类型，则通过 createTextVNode 方法转换成 VNode 类型；否则就已经是 VNode 类型了 if (isTextNode(last)) &#123; // merge adjacent text nodes // this is necessary for SSR hydration because text nodes are // essentially merged when rendered to HTML strings res[lastIndex] = createTextVNode(last.text + c) &#125; else if (c !== '') &#123; // convert primitive to vnode res.push(createTextVNode(c)) &#125; &#125; else &#123; // 其他类型 if (isTextNode(c) &amp;&amp; isTextNode(last)) &#123; // 如果当前节点是文本节点，那就和上一个文本节点合并（优化） // merge adjacent text nodes res[lastIndex] = createTextVNode(last.text + c.text) &#125; else &#123; /** 当前节点c是一个嵌套数组（比如v-for产生的） 比如： render: function (createElement) &#123; if (this.items.length) &#123; return createElement('ul', this.items.map(function (item) &#123; return createElement('li', item.name) &#125;)) &#125; else &#123; return createElement('p', 'No items found.') &#125; &#125; 根据 nestedIndex 去更新它的 key */ // default key for nested array children (likely generated by v-for) if (isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex)) &#123; c.key = `__vlist$&#123;nestedIndex&#125;_$&#123;i&#125;__` &#125; res.push(c) &#125; &#125; &#125; return res&#125; 上面也大致了解了 createElement 创建 VNode 的过程。每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了 DOM Tree。下一个步骤就是要把这个 VNode 渲染成一个真实的 DOM 并且渲染出来，这个过程是通过 vm._update 完成的。 参考：https://blog.csdn.net/sansan_7957/article/details/83014838https://cn.vuejs.org/v2/guide/render-function.htmlhttps://www.jianshu.com/p/709fc34e27b9]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue中css的scoped和deep解析]]></title>
      <url>%2F2019%2Fvue%E4%B8%ADscoped%E5%92%8Cdeep%E8%A7%A3%E6%9E%90.html</url>
      <content type="text"><![CDATA[[TOC] vue loader官网 scoped的作用 官方解释：当 &lt;style&gt; 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素，即它不影响外面，外面的也不影响里面，不过外面的样式可以通过继承影响里面的样式。 深度解析：scoped的作用是编译后给当前组件每个dom加一个独有的hash值 (data-v-xxxx)，假定为data-v-father，并且它的子组件的根元素也会加上这个hash值data-v-father，如果子组件style也是用来scoped则子组件每个dom元素也都有一个自己的hash值假定为data-v-child，所以子组件的根元素是有两个hash值的data-v-father和data-v-child. 12345678910111213141516171819// 父组件&lt;template&gt; &lt;div id="app"&gt; &lt;img width="25%" src="./assets/logo.png"&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt;------------------------------------------------------------------------// 子组件&lt;template&gt; &lt;div class="child-wrap"&gt; &lt;div class="child"&gt;sdfjhasfhjasdfj&lt;/div&gt; &lt;span&gt;4234&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 编译后：(父组件hash是data-v-7ba5bd90，子组件hash是data-v-763db97b) 1234567&lt;div data-v-7ba5bd90 id="app"&gt; &lt;img data-v-7ba5bd90 width="25%" src=""&gt; &lt;div data-v-763db97b data-v-7ba5bd90 class="child-wrap"&gt; &lt;div data-v-763db97b class="child"&gt;sdfjhasfhjasdfj&lt;/div&gt; &lt;span data-v-763db97b&gt;4234&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; scoped的效果会使得编译后的style中每个类名后面都会加上当前组件的hash值，如：.classA[data-v-father]，注意中间没有空格 123456789101112&lt;style lang="less" scoped&gt;#app &#123; .child2 &#123; color: blue; &#125;&#125;.child-wrap &#123; height: 300px;&#125;&lt;/style&gt; 编译后(当前组件hash值为data-v-7ba5bd90)： 12345678&lt;style&gt;#app .child2[data-v-7ba5bd90] &#123; color: blue;&#125;.child-wrap[data-v-7ba5bd90] &#123; height: 300px;&#125;&lt;/style&gt; deep的作用 官方解释：如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符，有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作 深度解析：上面讲了scoped的作用是使的每个组件内的class编译后都会在后面加上一个hash值，这样在父组件里即使写了子组件某个class，它编译后跟子组件的class也是不一样的。因此，如果需要在父组件里覆盖子组件的样式，除了使用全局class，还可以用deep deep的作用是在当前class前加上一个当前组件的hash值，并且去掉了scoped在后面加hash值的效果，如[data-v-father] .classA，注意中间是有空格的，由于子组件的根元素上是打了父组件hash值的，所以[data-v-father] .classA是可以定位到子组件上.classA元素的。 注意：deep保险的使用方法是前面要加上上层选择器的，如.wrap /deep/ .classA{}，如果deep前面不加上层选择器 1/deep/ .classA &#123;&#125; 不同的loader版本会编译成不同的情况： 12345有的deep是生效的，编译结果是[data-v-7ba5bd90] .classA&#123;&#125; // 中间有空格有的编译出来中间空格没了，deep的效果就不生效[data-v-7ba5bd90].classA&#123;&#125; // 中间没有空格 1234567&lt;style scoped&gt;#app &#123; /deep/ .child &#123; height: 200px; &#125;&#125;&lt;/style&gt; 将会编译成 12345&lt;style&gt;#app[data-v-7ba5bd90] .child &#123; height: 200px;&#125;&lt;/style&gt; #### 演示代码详见：https://codesandbox.io/s/mo184r48q9]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git删除commit历史记录]]></title>
      <url>%2F2019%2Fgit%E5%88%A0%E9%99%A4commit%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.html</url>
      <content type="text"><![CDATA[[TOC] 有时候你不小心将一些私人信息或者公司相关信息不小心上传到git上，虽然你重新提交，但是历史版本还是可以在git上看到，这时候就需要删除git上commit历史记录 方法一：亲测 思路是新建一个分支，把原来master分支上的东西拷过来，接着删除master分支，然后重命名成master，提交 这个方法比较狠，master上所有的历史提交都会没了 如何删除这些历史记录，形成一个全新的仓库，并且保持代码不变呢？ 123456789101112131415161718192021221.Checkout git checkout --orphan latest_branch2. Add all the files git add -A3. Commit the changes git commit -am &quot;commit message&quot;4. Delete the branch git branch -D master5.Rename the current branch to master git branch -m master6.Finally, force update your repository git push -f origin master 方法二使用 BFG Repo-Cleaner 这个工具，几分钟内就删除干净了，.git 目录大小由原来的 2.9G 左右缩减到 70M，删除过去提交的所有 tar.gz,zip,jar,war 等，只留下源码，总算能 push 到 github 了。 具体执行流程为： 12345bfg --delete-files *.tar.gz # 后面的文件名匹配可换成自己要删除的文件名git reflog expire --expire=now --allgit gc --prune=now --aggressivegit push --all --forcegit push --all --tags --force]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发模式：页面与接口解耦]]></title>
      <url>%2F2019%2F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A%E9%A1%B5%E9%9D%A2%E4%B8%8E%E6%8E%A5%E5%8F%A3%E8%A7%A3%E8%80%A6.html</url>
      <content type="text"><![CDATA[[TOC] 很多时候接口字段格式和页面所维护的字段格式并不是一样的，有些字段并不能直接绑定到element的组件上，或者element的组件返回的值需要经过处理才能得到接口需要的 下面讲下怎么设计model可扩展性更好 1234接口字段：apiDataModel页面维护的字段：localDataModel各个组件内部维护的字段：componentLocalDataModelurl中存储的字段：urlParamDataModel 现在要实现的功能是：正常流程：页面localDataModel改变了 –&gt; url需要记录请求参数，实现url分享功能 –&gt; 发起接口请求 从分享url进入页面：从url读取请求参数 –&gt; 初始化localDataModel –&gt; 走正常流程 不推荐的组织模式我以前习惯页面维护的localDataModel和接口的字段格式保持一致，这样在接口结构比较简单或者接口字段设计的比较好不需要做另外计算的时候是很快捷的一种方式，然而，一旦接口的参数格式和页面合不起来，这样的一种模式就会变得很臃肿，特别是后期有改动的时候就跟打补丁似的，东补一下西补一下，耦合性非常大，对接口的依赖性很严重，如果接口参数有变动可能逻辑调整很大。 如果apiDataModel并不能直接跟页面合起来（就是字段不能直接绑定到组件的v-model，比如组件v-model要求的是个对象但接口要求的是个数组），这种情况下localModel用apiDataModel的格式，就需要在各个组件内部再维护各自跟页面相合的componentLocalModel，localModel需要初始化componentLocalDataModel，且componentLocalDataModel变化了需要传出来改变localDataModel，这样很容易成死循环。 推荐的组织模式 在model.js中维护一个apiDataModel，apiDataModel字段格式与接口要求的格式一致。 然后在vue文件中维护一个localDataModel，localDataModel字段格式最好是可以直接绑定页面组件的v-model，这样组件变化了不用进行中间转换。 在用户点击了提交操作的时候，先将localDataModel的值push进URL，即赋值给urlParamDataModel，然后再在model.js中将localDataModel转换成apiDataModel，最后发请求。 在页面初始化的时候，从url中获取参数，即用urlParamDataModel去初始化localDataModel。 如果系统要先用接口获取来的数据初始化页面而不需要从url中读取数据，那么先从接口拉取数据存到apiModel，然后在model.js中将apiModel转换成localDataModel的格式返给localDataModel。 总而言之，和接口相关的东西都放在model.js中处理，与页面渲染相关的放在vue文件里，model.js中作为中间层负责接口和渲染层的转换，这样当接口后期有变动的时候只需要改model.js中的东西，vue文件就不需要什么改动。vue文件放跟接口耦合性不大的东西。 当然，localDataModel和apiDataModel之间是越接近越好，比如localDataModel设计成需要从好几个地方获取数据才能拼合成接口数据apiDataModel，这样工作量反而增大了，而且数据之间的同步也是个问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue监听不到数组更新]]></title>
      <url>%2F2019%2Fvue%E7%9B%91%E5%90%AC%E4%B8%8D%E5%88%B0%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0.html</url>
      <content type="text"><![CDATA[123toogleArrowHandler(index) &#123; this.isArrowOpen[index] = !this.isArrowOpen[index];&#125; 在vue中像上面一样直接改变数组的值不是响应式的，vue监听不到数组的变化 原因：vue中数组直接给单个挂载的时候不存在的某项赋值是监听不到的，需要整体给数组赋值或者数据挂载的时候就存在该项才是响应式的（对象也是同样的道理） 解决办法 需要整体给数组赋值 数据挂载的时候就存在该项 使用splice(旧元素index，1，新元素)，先删后加，vue会监听splice]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[element的switch样式不生效问题]]></title>
      <url>%2F2019%2Felement%E7%9A%84switch%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[在使用element的时候checkbox的样式没有滑块问题 原因： element-ui 版本和 element-ui 的 theme 对不上 解决： theme所依赖的element版本应该大于等于ui的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用loader统一改element主题色]]></title>
      <url>%2F2019%2F%E4%BD%BF%E7%94%A8loader%E7%BB%9F%E4%B8%80%E6%94%B9element%E4%B8%BB%E9%A2%98%E8%89%B2.html</url>
      <content type="text"><![CDATA[babelrc中将libraryName的ui组件和styleLibraryName中的theme主题关联起来：使用的是babel-plugin-component插件，该插件是在你每次使用组件的时候会require组件文件和对应的样式文件（默认是css，可以通过ext改变引用的文件后缀），改element主题色的时候我们引用scss文件 然后scss文件在webpack编译的时候指定走styleLoaders，然后在styleLoaders里指定给scss文件使用(sass-resources-loader)[https://www.npmjs.com/package/sass-resources-loader]插件处理，sass-resources-loader作用是给每个required的scss文件头部加上你指定的文件的内容，这样可以给每个required的scss文件添加一个变量，替换element原有的主题变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生成umd的时候element的主题报错]]></title>
      <url>%2F2019%2F%E7%94%9F%E6%88%90umd%E7%9A%84%E6%97%B6%E5%80%99element%E7%9A%84%E4%B8%BB%E9%A2%98%E6%8A%A5%E9%94%99.html</url>
      <content type="text"><![CDATA[[TOC] 使用场景项目需要用rollup打包生成umd文件，在开发的时候按需引用了element的message组件（没有手动引用theme），在打包的时候报错： 12[!] Error: Unexpected tokennode_modules/element-theme/lib/message.css (1:0) 问题原因：不支持import css 解决：装个插件 “rollup-plugin-postcss”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue子组件中data的数据从props中获取并不会动态更新问题]]></title>
      <url>%2F2018%2Fvue%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%8Eprops%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%B9%B6%E4%B8%8D%E4%BC%9A%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[[TOC] 父组件中的数据变化了是会动态更新到子组件的props上的，但是如果你在子组件的data中又定义了个变量引用了props中的值，这个子组件中的data变量是不会跟着props动态更新的。 解决办法就是子组件中使用watch跟踪下props中的变量。 123456// 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;chart :info=&apos;info&apos;/&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223// 子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul&gt; &lt;!-- 此处 list 来自 data --&gt; &lt;li v-for=&quot;i in list&quot; :key=&apos;i&apos;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;info&apos;], data () &#123; return &#123; list:[], &#125; &#125;, mounted()&#123; this.list = this.info.map(i =&gt; &apos;0_&apos;+i) &#125;,&#125;&lt;/script&gt; 解决办法：12345678910111213141516171819202122232425262728// 子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul&gt; &lt;!-- 此处list 来自 data --&gt; &lt;li v-for=&quot;i in list&quot; :key=&apos;i&apos;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;info&apos;], data () &#123; return &#123; list:[], &#125; &#125;, mounted()&#123; this.list = this.info.map(i =&gt; &apos;0_&apos;+i) &#125;, watch: &#123; info() &#123; this.list = this.info &#125; &#125;&#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS-webpack打包后-webkit-box-orient:vertical;消失了]]></title>
      <url>%2F2018%2FCSS-webpack%E6%89%93%E5%8C%85%E5%90%8E-webkit-box-orient-vertical%3B%E6%B6%88%E5%A4%B1%E4%BA%86.html</url>
      <content type="text"><![CDATA[[TOC] 多行超出添加省略号的css代码：1234display: -webkit-box;-webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; vue项目中经过webpack打包后，发现样式没有生效，在浏览器调试模式下，发现-webkit-box-orient: vertical;该属性消失了。 参考segmentfault上的一个问答（原文），原来是webpack打包的问题，详情见该issues（https://github.com/postcss/autoprefixer/issues/776）。 在sass样式代码中，添加一个webpack注释，关掉某行的自动添加css前缀。12345display: -webkit-box; /*! autoprefixer: off */ -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块化编程:CommonJS、AMD、ES6模块化]]></title>
      <url>%2F2018%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B-CommonJS%E3%80%81AMD%E3%80%81ES6%E6%A8%A1%E5%9D%97%E5%8C%96.html</url>
      <content type="text"><![CDATA[[TOC] 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 下面比较现有的三种模块化编程方案： CommonJS AMD ES6 比较： CommonJS大多数用于服务器端开发，运行时加载 AMD大多数用于浏览器客户端开发，运行时加载 ES6：编译时加载，尽量实现静态化CommonJS 一般用于服务器端 NodeJS是CommonJS规范的实现12var math = require(&apos;math&apos;);math.add(2,3); // 5 require是同步的 AMD（异步模块定义） 一般用于浏览器客户端 包含：RequireJsrequire是同步的对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。AMD也适用require，但是使用回调函数执行后面动作12345require([&apos;math&apos;], function (math) &#123; math.add(2, 3); &#125;); ES6ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性 ES6可以通过模块接口取到模块内部实时的值，这一点与 CommonJS 规范完全不同，CommonJS 模块输出的是值的缓存，不存在动态更新 ES6的模块化是在编译时加载的，有作用域提升的效果 ES6中import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 【潦草记录】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[axios小结]]></title>
      <url>%2F2018%2Faxios%E5%B0%8F%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC] 请求格式GET请求123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); POST请求12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 配置选项这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123; // `url` 是用于请求的服务器 URL url: &apos;/user&apos;, // `method` 是创建请求时使用的方法 method: &apos;get&apos;, // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &apos;Fred&apos; &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125;, // `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &apos;proxy&apos; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: : &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; API可以通过向 axios 传递相关配置来创建请求axios(config) 请求方法别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 并发请求axios.all(iterable)axios.spread(callback)axios.all()的目的是批量发送请求，等所有请求都有返回时，再执行统一的回调，并不是把所有的请求合并成同一个请求发送12345678910111213141516fn1()&#123; return axios.get(&apos;/fn1&apos;) &#125;fn2() &#123; return axios.get(&apos;/fn2&apos;)&#125;axios.all([ fn1(); fn2();]).then(axios.spread((res1, res2) =&gt; &#123;// axios.all里的请求都完成后，才执行这个回调方法 console.log(res1); console.log(res2);&#125;)); 创建实例可以使用自定义配置新建一个 axios 实例123456axios.create([config])var instance = axios.create(&#123; baseURL: &apos;https://some-domain.com/api/&apos;, timeout: 1000, headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue中的key解析]]></title>
      <url>%2F2018%2Fvue%E4%B8%AD%E7%9A%84key%E8%A7%A3%E6%9E%90.html</url>
      <content type="text"><![CDATA[[TOC] vue中的key是DOM更新时识别是否复用的标志，如果key一样则认为该DOM可以复用。如果key加在组件上是可以使得该组件的每个副本都有自己的生命周期，如在组件上有v-for：1&lt;componentA v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/componentA&gt; 如果不加上key的话那这些循环出来的组是共用一个生命周期的，可能会产生干扰。 key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 最常见的用例是结合 v-for：123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子触发过渡例如：123&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时， 会随时被更新，因此会触发过渡。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue中v-for与key]]></title>
      <url>%2F2018%2Fvue%E4%B8%ADv-for%E4%B8%8Ekey.html</url>
      <content type="text"><![CDATA[[TOC] vue官方说： 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 今天碰到个问题，在使用tab切换时，表格的列项顺序并不是定义的顺序123456789101112131415161718&lt;div class=&quot;tabs&quot;&gt; &lt;el-radio-group v-model=&quot;tabs&quot; size=&quot;small&quot; &gt; &lt;el-radio-button &gt;列表1&lt;/ks-el-radio-button&gt; &lt;el-radio-button &gt;列表2&lt;/ks-el-radio-button&gt;&lt;/div&gt;&lt;section&gt; &lt;table&gt; &lt;template v-for=&quot;item in arr&quot;&gt; &lt;col :key=&quot;item+&apos;1&apos;&quot;&gt;a&lt;/col&gt; &lt;col :key=&quot;item+&apos;2&apos;&quot;&gt;b&lt;/col&gt; &lt;/template&gt; &lt;/table&gt;&lt;/section&gt; 当在切换tab的时候，想a列和b列的顺序是调换的，然而由于tab切换时两列的key没有变，先对比新旧dom的key变化，如果新的dom中key值没有变化（不管顺序），那么，尽管新dom的数据项顺序变了，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是使用旧dom的顺序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue遇到的问题总结]]></title>
      <url>%2F2018%2Fvue%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC] $nextTick123456789101112watch: &#123; a() &#123; 更新数据 &#125;&#125;method:&#123; submit()&#123; this.a = xxx; this.$emit(&apos;close&apos;); &#125;&#125; 有时候会碰到element的dialog在关闭的时候在watch中的东西来不及执行的情况，这是因为在关闭dialog之前来不及执行更新数据部分。现在的需求是需要在数据更新之后才关闭窗口，可以用nextTick是在DOM更新的时候触发的，数据更新了会引起最外层虚拟DOM更新，最终会引发dialog的DOM更新，所以上面可以写成：123456789101112131415watch: &#123; a() &#123; 更新数据 &#125;&#125;method:&#123; submit()&#123; this.a = xxx; this.$nextTick(function () &#123; // 等到watch数据、DOM更新完才关闭窗口 this.$emit(&apos;close&apos;); &#125;); &#125;&#125; 【持续更新中…】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[element中table表头不换行]]></title>
      <url>%2F2018%2Felement%E4%B8%ADtable%E8%A1%A8%E5%A4%B4%E4%B8%8D%E6%8D%A2%E8%A1%8C.html</url>
      <content type="text"><![CDATA[[TOC] 使用el-table做一个表格，当表头内容过长时会换行，在不设置的宽度的时候每一列的宽度是等比例分配的，虽然element-ui中提供了width和min-width这个属性可以自由设置。 但是因为要做的表格很多，而且要一一计算比例然后再赋值给width也是一件很繁琐的事。 element中每个column都有一个属性render-header，它是渲染这一列的列标题区域所用的函数。 12345&lt;el-table border :data=&quot;tableData&quot; v-loading=&quot;loading&quot; :row-class-name=&quot;tableRowClassName&quot;&gt; &lt;el-table-column v-for=&quot;(item,index) in tableColumn&quot; :label=&quot;item.name&quot; :prop=&quot;item.prop&quot; v-if=&quot;item.show&quot; :key=&quot;index&quot; align=&quot;center&quot; :render-header=&quot;tableHead&quot;&gt;&lt;/el-table-column&gt;&lt;/el-table&gt; 123456789methods: &#123; tableHead(h, &#123;column&#125;) &#123; let wordsLength = column.label.length; let fontSize = 14; // 每个字大小，其实是每个字的比例值，大概会比字体大小差不多大一点， column.minWidth = fontSize * wordsLength + 50; // 字大小乘个数即长度 ,注意不要加px像素，这里minWidth只是一个比例值，不是真正的长度 // 然后将列标题放在一个span中，注意块的宽度一定要100%，否则表格显示不完全 return h(&apos;span&apos;, &#123;class: &apos;table-head&apos;, style: &#123;width: &apos;100%&apos;&#125;&#125;, [column.label]); &#125;&#125; 123.table-head&#123; font-size:14px !important;//设置固定的字体大小 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于echarts数据更新后，图没有更新的问题]]></title>
      <url>%2F2018%2F%E5%85%B3%E4%BA%8Eecharts%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%8C%E5%9B%BE%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[[TOC] 在用echarts折线图的时候，一开始往echarts的series中输入的是6条数据，然后动态更新数据后，往echarts的series中输入的是3条数据，重新setOption后发现图表上还是6条数据。 接着开始console.log，发现确实只有3条数据的值，说明值已变更但是图表没有更新 后来百度后发现解决办法： 原来set的时候是：this.charts.setOption(lineOption); 正确的应该是： this.charts.setOptionlineOption,true); 再次刷新，问题解决。 查看官方文档后发现setOption有4个属性setOption(option, notMerge, lazyUpdate, silent): option:图表的配置项和数据，具体见配置项手册。 notMerge:可选，是否不跟之前设置的option进行合并，默认为false，false表示合并数据,置为true之后则不合并数据了，就可以实现刷新数据的效果了。 lazyUpdate:可选，在设置完option后是否不立即更新图表，默认为false，即立即更新。 silent:可选，阻止调用 setOption 时抛出事件，默认为false，即抛出事件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue数据响应式注意点]]></title>
      <url>%2F2018%2Fvue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="text"><![CDATA[[TOC] 今天在使用某个对象obj的数据控制table的列动态显示的时候，无论obj怎么变化，表格都不会动态更新。找大佬查了半天，发现是数据响应式的问题，在vue官方文档中还特别提过这个坑，还是要多看看文档的。https://cn.vuejs.org/v2/guide/reactivity.html obj在data中初始化的时候是个空对象，在更新obj的时候直接用的是添加属性12345678data: &#123; obj: &#123;&#125;&#125;watch: &#123; test() &#123; obj[key1] = val1; &#125;&#125; 这样无法检测到obj变化。在vue文档中说过： 受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue转换它，这样才能让它是响应的 解决这个问题有两种方法：1.在data里实现就生命好属性key12.利用中间遍历12345678910data: &#123; obj: &#123;&#125;&#125;watch: &#123; test() &#123; const temp=&#123;&#125;; temp[kee1] = val1; obj = temp; &#125;&#125; 这样也是能检测到obj变化的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用after伪元素实现hr效果]]></title>
      <url>%2F2018%2F%E5%88%A9%E7%94%A8after%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%60-hr-%60%E6%95%88%E6%9E%9C.html</url>
      <content type="text"><![CDATA[[TOC] 1&lt;div class=&quot;item&quot;&gt; 123456789101112.item&#123; position: relative; &amp;:after &#123; display: block; position: absolute; width: 100%; left: 0; bottom: 0; border-bottom: 1px rgba(7, 17 , 27, 0.1) solid; content: ' '; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中new与Object.create()的区别深入解析]]></title>
      <url>%2F2018%2FJS%E4%B8%ADnew%E4%B8%8EObject.create()%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90.html</url>
      <content type="text"><![CDATA[[TOC] 在网上看了很多关于new与Object.create()的区别的文章，看的稀里糊涂的，各种说法的都有，看“你不懂的JS”那本书上也提到了这个，看的怀疑人生了。遂自己总结下认为比较说的通的一种理解。 函数都有prototype，对象(包括函数)都有__proto__ new12345678910function Test()&#123; this.a = 1;&#125;Test.prototype.say = function() &#123; console.log(this.a);&#125;var testA = new Test();testA.a = 2;delete testA.a;console.log(testA.a);//undefined new首先创建一个空对象testA，然后改变this调用Test构造函数,最后将新对象的浏览器属性__proto__指向Test的原型 123var testA =&#123;&#125;;Test.apply(testA);testA.__proto__ = Test.prototype; Object.create()123456789function Test()&#123; this.a = 1;&#125;Test.prototype.say = function() &#123; console.log(this.a);&#125;var testB = Object.create(Test);testB.a = 2;console.log(testA.a);//打印 2 创建一个临时对象F,最终testB的__proto__指向Test构造函数 12345Object.prototype.create = function(Test)&#123; var F = Function ()&#123;&#125;; F.prototype = Test; return new F();&#125; 感觉还是没彻底讲清楚。未完待续吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Element中使用dialog实现下一步出现闪屏现象解决方法]]></title>
      <url>%2F2018%2FElement%E4%B8%AD%E4%BD%BF%E7%94%A8dialog%E5%AE%9E%E7%8E%B0%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%87%BA%E7%8E%B0%E9%97%AA%E5%B1%8F%E7%8E%B0%E8%B1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
      <content type="text"><![CDATA[[TOC] 弹窗出现下一步下一步这种页面很常见，使用element ui时一般用dialog实现，如果每一步的弹窗都用一个dialog的话，那么在点击“下一步”，两个dialog弹窗切换的时候会出现闪屏现象，这是因为前一个dialog关闭，新dialog打开有一段时间间隙，会有明显的遮罩层切换效果。 为了避免闪屏现象，可以让所有内容在同一个dialog中，当点击下一步的时候，将dialog的内容动态切换。 12345678910111213141516171819202122232425262728&lt;el-button type=&quot;text&quot; @click=&quot;dialog = true;choosed=&apos;one&apos;&quot;&gt;点击打开 Dialog&lt;/el-button&gt;&lt;el-dialog :visible.sync=&quot;dialog&quot;&gt; &lt;div v-if=&quot;choosed===&apos;one&apos;&quot;&gt; &lt;h2&gt;第1步&lt;/h2&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;choosed=&apos;two&apos;&quot;&gt;下一步&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-if=&quot;choosed===&apos;two&apos;&quot;&gt; &lt;h2&gt;第2步&lt;/h2&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;choosed=&apos;three&apos;&quot;&gt;下一步&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; ... &lt;/el-dialog&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; dialog: false, choosed: &apos;one&apos; &#125;; &#125; &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue-cli4定制自己的模板]]></title>
      <url>%2F2018%2Fvue-cli4%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A8%A1%E6%9D%BF.html</url>
      <content type="text"><![CDATA[通过vue-cli插件方式定制自己的模板，cli插件包括以下功能：1.修改webpack配置2.与用户进行交互，用户选择所需的一些功能模块3.扩展package.json4.创建、修改生成的项目文件5.添加新的 vue-cli-service 命令 插件文件结构通常的 CLI 插件目录结构看起来像下面这样： 1234567.├── README.md├── generator.js 或者generator文件夹 # 修改或者生成项目文件（可选）├── index.js # service 插件├── package.json├── prompts.js # 交互文件（可选）└── ui.js # Vue UI 集成（可选） 插件命名规范为了让一个 CLI 插件在 Vue CLI 项目中被正常使用，它必须遵循 vue-cli-plugin-&lt;name&gt; 或者 @scope/vue-cli-plugin-&lt;name&gt; 这样的命名惯例。例如：vue-cli-plugin-template-preset，这样你的插件才能够： 被 @vue/cli-service 发现； 被其他开发者通过搜索发现； 通过 vue add &lt;name&gt; 或者 vue invoke &lt;name&gt; 安装 插件安装 本地安装 123456// 1.如果没有项目就创建个新的vue create my-app// 2.安装本地插件npm install --save-dev file:/full/path/to/your/pluginvue invoke vue-cli-plugin-template-preset 使用preset自动在线安装插件 1vue create --preset vue-cli-plugin-template-preset my-app 手动在线安装 123vue create my-appcd my-appvue add vue-cli-plugin-template-preset Generator修改文件 在 CLI 插件内部，generator 应该放在 generator.js 或者 generator/index.js 文件中。它将在以下两个场景被调用： 项目初始创建期间，CLI 插件被作为项目创建 preset 的一部分被安装时。 当插件在项目创建完成和通过 vue add 或者 vue invoke 单独调用被安装时。 一个 generator 应该export一个接收三个参数的函数 123456789/*** generator/index.js* api: https://cli.vuejs.org/dev-guide/generator-api.html* options: prompt用户交互结果或者 `~/.vuerc`中的option值* rootOptions: `~/.vuerc`中的该preset整个值，相当于下面例子的 foo 对象值*/module.exports = (api, options, rootOptions) =&gt; &#123; // 使用提供的api或者option进行一些定制&#125; // ~/.vuerc文件格式 { &quot;presets&quot; : { &quot;foo&quot;: { &quot;plugins&quot;: { &quot;@vue/cli-plugin-foo&quot;: { &quot;option&quot;: &quot;bar&quot; } // generator拿到的option值 } } } } 一些常用的generator api api.render(&#39;./template&#39;) 渲染EJS模板 api.extendPackage api.entryFile api.afterInvoke api.chainWebpack api.registerCommand 1234567891011121314// generator.jsmodule.exports.hooks = (api) =&gt; &#123; api.afterInvoke(() =&gt; &#123; const &#123; EOL &#125; = require('os') const fs = require('fs') const contentMain = fs.readFileSync(api.resolve(api.entryFile), &#123; encoding: 'utf-8' &#125;) const lines = contentMain.split(/\r?\n/g) const renderIndex = lines.findIndex(line =&gt; line.match(/render/)) lines[renderIndex] += `$&#123;EOL&#125; router,` fs.writeFileSync(api.entryFile, lines.join(EOL), &#123; encoding: 'utf-8' &#125;) &#125;)&#125; 模板文件生成 新文件： 1234// 放到template文件夹下，然后用api.render解析module.exports = api =&gt; &#123; api.render('./template')&#125; 编辑已存在的文件 方式一： 12345678910---extend: '@vue/cli-service/generator/template/src/App.vue' // 目标文件replace: !!js/regexp /&lt;script&gt;[^]*?&lt;\/script&gt;/ // 正则匹配内容---&lt;script&gt;export default &#123; // Replace default script&#125;&lt;/script&gt; 方式二：多处替换 123456789101112131415161718---extend: '@vue/cli-service/generator/template/src/App.vue'replace: - !!js/regexp /Welcome to Your Vue\.js App/ - !!js/regexp /&lt;script&gt;[^]*?&lt;\/script&gt;---&lt;%# REPLACE %&gt;替换欢迎信息&lt;%# END_REPLACE %&gt;&lt;%# REPLACE %&gt;&lt;script&gt;export default &#123; // 替换默认脚本&#125;&lt;/script&gt;&lt;%# END_REPLACE %&gt; 3.扩展package.json 1234567module.exports = api =&gt; &#123; api.extendPackage(&#123; dependencies: &#123; 'vue-router-layout': '^0.1.2' &#125; &#125;)&#125; 4.主文件注入 1234567891011121314151617module.exports.hooks = (api) =&gt; &#123; api.afterInvoke(() =&gt; &#123; const &#123; EOL &#125; = require('os') const fs = require('fs') // 读取文件 const contentMain = fs.readFileSync(api.resolve(api.entryFile), &#123; encoding: 'utf-8' &#125;) // 文件内容分行 const lines = contentMain.split(/\r?\n/g) // 查找到render那一行 const renderIndex = lines.findIndex(line =&gt; line.match(/render/)) lines[renderIndex] += `$&#123;EOL&#125; router,` // 写入 fs.writeFileSync(api.entryFile, lines.join(EOL), &#123; encoding: 'utf-8' &#125;) &#125;)&#125; 5.修改webpack配置 对话所有的对话逻辑都存储在 prompts.js 文件中，用于用户选择所需的插件。所有对话的答案都会传给generator的option 和 rootOptions 对话的配置项（所有配置项） 1234567891011// prompts.jsmodule.exports = [ &#123; name: `addExampleRoutes`, // option的key type: 'confirm', // 选项类型：checkbox、confirm message: 'Add example routes?', // 对话显示的提示信息 default: false, // 默认值 validate: input =&gt; !!input, // 校验用户的答案，true则通过，否则返回错误提示字符串 &#125;] 参考: 1.插件开发指南 | Vue CLI]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【设计模式】发布-订阅模式]]></title>
      <url>%2F2018%2F%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</url>
      <content type="text"><![CDATA[[TOC] 发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变的时候，所有依赖于它的对象都将得到通知。 举个栗子比如售楼中心，因为房源紧张，小红、小明、老王每天都要打电话到售楼前台询问今天是否有新楼盘，这样售楼前台每天就需要接收很大量的咨询。发布-订阅模式就是，售楼前台MM将每个人的电话都记录下来，当有新楼盘的时候，就遍历一遍这些电话号码，依次打电话通知。其中售楼前台是发布者，小红、小明、老王是订阅者。优点： 在合适的时间发布者会通知订阅者。这说明发布-订阅模式可以广泛应用于异步编程中，可以替代回掉函数的方式，无需过多关心异步运行期间的内部状态，只需要订阅感兴趣的事件发生点。 减少发布者和订阅者之间的耦合，发布者只记录一个订阅者的电话，并不关心订阅者是女人还是猴子。这个优点说明可以订阅-发布模式可以取代对象之间硬编码的通知机制，不需要再显式的调用另一个对象的某个接口，这让对象之间松耦合的联系在一起，当新订阅者出现的时候，发布者代码不需要作任何修改，同理，当发布者需求改变时也不会影响到之前的订阅者。 典型应用场景 时间解耦：应用于异步编程 对象解耦：接口之间调用不再显示的进行 发布-订阅模式通用实现12345678910111213141516171819202122var event = &#123; clientList: [], //缓存列表，存放订阅者的回掉函数 // 增加订阅者 addListen: function (key, fn) &#123; // key是订阅的消息类型，fn是回调函数 if (!this.clientList[key]) &#123; this.clientList[key] = []; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 &#125; this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表 &#125;, // 发布消息 emit: function () &#123; var key = Array.prototype.shift.call(arguments), // 取出消息类型 fns = this.clientList[key]; // 取出该类型的消息对应的回调函数组成的数组 if(!fns || fns.length === 0) &#123; return false; &#125; for (var i=0,fn; fn = fns[i++]) &#123; fn.apply(this, arguments); //arguments是发布消息时附送的参数 &#125; &#125;&#125; 再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能:123var installEvent = function( obj )&#123; for ( var i in event )&#123; 给obj对象安装发布-定义模式 obj[ i ] = event[ i ]; &#125;&#125;; 给售楼处对象增加发布-订阅功能：12345678910111213141516var salesOffice = &#123;&#125;;installEvent(salesOffice); // 添加订阅-发布完毕// 对象小明订阅消息salesOffice.addListen(&apos;square88&apos;, function(price) &#123; console.log( &apos;价格= &apos; + price );// 回调函数&#125;);// 对象小红订阅消息salesOffice.addListen(&apos;square100&apos;, function(price) &#123; console.log( &apos;价格= &apos; + price );// 回调函数&#125;);// 发布消息salesOffices.emit( &apos;square88&apos;, 2000000 ); // 输出2000000salesOffices.emit( &apos;square100&apos;, 3000000 ); // 3000000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】Set和Map数据结构]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
      <content type="text"><![CDATA[[TOC] Set集合特性 Set类型的数据类似于数组，它是一种特殊的数据结构，但是它包含的没有重复的值 在往Set内加入值的时候不会自动发生类型转换，5和’5’是两个不同的值，NaN是等于自身的 Set结构的键名就是键值 基本用法1、创建Set数据结构123const items1 = new Set(); const items2 = new Set([1,2,3,4,5]); 12// 去除数组的重复成员[...new Set(array)] 2、在Set数据结构中两个对象总是不想等的，下面这种方式加人的两个对象不是指向同一个 但是，如果是下面这种方法加人对象的话是只能加入一次的，因为obj变量是只想同一个对象 1234const b = new Set();const obj = &#123;bb: 123&#125;;b.add(obj);b.add(obj);／／两个只会加人一个 Set实例属性和方法 const set = new Set() 1.set.size：定义在Set原型上的属性，Set.prototype.size,返回Set实例成员总数 2.set.add(value)：添加某个值( 可以是对象)到Set实例中，返回Set结构本身 3.set.delete(value)：删除Set实例中的某个值( 可以是对象)，返回一个布尔值，表示删除是否成功 4.set.has(value)：查询Set实例中是否有value成员( 可以是对象)，返回一个布尔值表示是否有 5.set.clear() ：清除set所有成员，没有返回值 Set的遍历1.set.keys()、set.values()、set.entries()：Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。123456789101112131415161718192021let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 注：Set结构的实例是默认可遍历的1234567let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x);&#125;// red// green// blue 2.set.forEach()：Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))// 1 : 1// 4 : 4// 9 : 9 3.扩展运算符...可以展开Set数据结构，其内部也是使用for…of循环,需要用[]包裹着 其他相关方法 1.Array.from()可以将Set结构转为数组12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 数组去重：Array.from(new Set(arr)) WeakSet集合WeakSet集合于Set集合类似，也是不重复的值，它们之间的区别是： WeakSet的成员只能是对象，不能是其他类型的值 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 创建WeakSet12const ws = new WeakSet();ws.add(&#123;a:1&#125;); 实例方法WeakSet 结构有以下三个方法。 WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 123456789101112const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet 没有size属性，没有办法遍历它的成员。WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。 Map集合Map数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现. 只有对同一个对象的引用，Map 结构才将其视为同一个键 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等,才认为是同一个键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键 添加往Map数据结构里添加元素1.xx.set(键，值)2.构造函数Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。12345const map = new Map([ [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;]]);map.get(&apos;name&apos;) // &quot;张三&quot; 实例属性和方法1.size属性2.map.set(key, val)3.map.get(key, val)：读取key对应的键值，如果找不到就返回undefined1234const m = new Map();const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;m.set(hello, &apos;Hello ES6!&apos;) // 键是函数m.get(hello) // Hello ES6! 4.map.has(key)：返回一个布尔值，表示某个键是否在当前Map对象之中5.map.delete(key)：删除某个键，返回true，失败则返回false6.map.clear()：清除所有成员 遍历keys()：返回键名的遍历器。values()：返回键值的遍历器。entries()：返回所有成员的遍历器。forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。 Map与其他数据结构的互相转换1.Map =&gt; 数组1let arr = [...map] 2.数组 =&gt; Map将数组传入 Map 构造函数，就可以转为 Map。12345678new Map([ [true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]// &#125; 3.Map =&gt; 对象123456 let obj = Object.create(null); for (let [k,v] of map) &#123; obj[k] = v; &#125; return obj;&#125; 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。 4.对象 =&gt; Map1234let map = new Map(); for (let k of Object.keys(obj)) &#123; map.set(k, obj[k]); &#125; 5.Map =&gt; JSON一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。123function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。1return JSON.stringify([...map]); 6.JSON =&gt; Map所有键名都是字符串123function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125; WeakMapWeakMap与Map的结构类似，也是用于生成键值对的集合。WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据WeakMap与Map区别： WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 WeakMap作用： DOM 节点作为键名，存储DOM节点的一些信息 部署私有属性，当实例消失全局生命的WeakMap变量就消失，不会造成内存泄漏12345678910111213141516171819202122const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log(&apos;DONE&apos;));c.dec()c.dec()// DONE]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git合作开发简单流程]]></title>
      <url>%2F2018%2F%E5%A4%9A%E4%BA%BA%E5%90%88%E4%BD%9Cgit%E5%88%86%E6%94%AF%E6%8F%90%E4%BA%A4.html</url>
      <content type="text"><![CDATA[[TOC] 在使用git合作开发的时候，流程是 在本机使用分支进行开发 开发完毕后先把master最新代码合入进来，处理好冲突，然后推送到远程分支，在gitlab上发送merge request给相关同学进行code review merge request通过后及时删除不用的分支 下面是详细的操作过程 1、创建并切换到新分支：1git checkout -b newBranchName 2、把本地修改的文件添加到暂存区去1git add . 3、创建改动说明（还未提交到远程仓库）1git commit -m &apos;代码版本说明&apos; 4、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）1git pull --rebase origin master 5、把本地仓库内容推送到远程1git push 6、到gitlab上点击merge request指定大佬给你review代码 其他一些命令1.git stash:当你想要保存当前的暂存区和工作区的状态的时候，你可以使用git stash命令。比如：你正在开发一个新功能，写了一些代码（保存暂存的和没有暂存的或没有记录的），现在需要去修复一个紧急bug，你又不想提交，这时你可以选择保存当前工作区和暂存区的内容，需要的时候恢复。 这个命令会保存当前的暂存区和工作区的状态，然后返回到HEAD（git reset —hard HEAD） 处理完毕后返回保存的工作区可以用git stash pop弹出 2.版本回滚：git reset 1git reset --hard 版本号 其中的版本号没有必要写全，可以通过git log查看版本号 git reset --hard HEAD^是回退到上一个版本 3.当你正在一个新分支a上开发时，突然接到一个需要到以前分支b上进行bug修改的需求，这个时候先用git stash暂存a分支的代码，然后git checkout b分支改bug，这个时候你会发现a分支上的那些新增的文件也会在b分支上出现，但是你又不想在b分支上提交这些a分支上新增的文件，这个时候在b分支修改完代码后使用git commit -am &#39;fix: xxx&#39;提交b分支上的代码，并不会将新增文件算进去。 commit类型 init：项目初始化（用于项目初始化或其他某种行为的开始描述，不影响代码） feat：新功能（feature） fix：修补bug docs：文档（documentation） opt：优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等 style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 save：单纯地保存记录 other：用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore之类的可以使用） 踩坑记1.rebase：假设你现在基于远程”master”，创建一个叫”mywork”的分支。现在我们在这个分支做一些修改，然后生成多个提交(commit).但是与此同时，有些人也在”master”分支上做了一些修改并且做了提交了. 这就意味着”master”和”mywork”这两个分支各自”前进”了。当在本地使用git pull origin master后有冲突的文件并不会将最新版本的mywork分支与master分支合并，需要使用git rebase 一个一个版本进行解决冲突，在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:git rebase --continue直到最后都是最新版本。 可参考： git命令 Github 创建新分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue中computed、method、watch区别]]></title>
      <url>%2F2018%2Fvue%E4%B8%ADcomputed%E3%80%81method%E3%80%81watch%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[[TOC] computed 计算属性不能是在data里定义过的 computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化 在Vue中计算属性是基于它们的依赖进行缓存的，而方法是不会基于它们的依赖进行缓存的。从而使用computed属性要比method性能更好。 computed有缓存，若相关数据未发生变化，则不调用； method 通过触发一个事件或者函数的回调来实现数据的更新，他的执行，依赖于事件的触发 watch watch主要用于监控vue实例的变化，它监控的变量当然必须在data里面声明才可以，它是监控单个变量或对象 消耗比较大 watch多用于数据交互频繁的内容。（例如定时axios从服务器获取数据） 可以参考的文章：vue中mothods，computed,watch方法的区别Vue的computed和watch的细节全面分析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue router小结]]></title>
      <url>%2F2018%2Fvue%20router%E5%B0%8F%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC] 要点： 路由的不同页面实质就是动态加载不同的组件 每一个xx.vue就是一个组件 SPA（单页应用）单核心就是前端路由，单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。 本文使用vue-cli搭建的应用 分类前端路由分为两种： hash模式：利用url的hash，也就是锚点#，js需要通过hashChange事件来监听url的改变，ie7以下需要轮询 history模式：另一种就是利用html5的history模式，像后端路由一样用/分割，但是页面并没有跳转 hash形式路由 hash路由形式：http://www.xxx.com/#/login url 的 hash 是以 # 开头，原本是用来作为锚点，从而定位到页面的特定区域。每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：12345function matchAndUpdate () &#123; // 匹配 hash 做 dom 更新操作&#125;window.addEventListener(&apos;hashchange&apos;, matchAndUpdate) history模式路由 HTML5 规范中提供了history.pushState和history.replaceState来进行路由控制。通过这两个方法，可以实现改变 url 且不向服务器发送请求。 使用这种模式需要服务端的支持，因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。。 使用history模式需要在vue router的router/index.js中设置mode: &#39;history&#39;，没写这个可能会不显示 vue-router使用目录说明：在/src目录下有个/router/目录，路由设置一般在/router/目录下文件中设置，一般/src/router/index.js是路由入口（vue-cli） 1、在/src/router/index.js中引入 import Router from &#39;vue-router&#39;;2、使用插件：Vue.use(VueRouter);3、创建路由规则，在routes属性中创建路由规则4、将其路由对象传递给Vue的实例，options中加入 router:router5、在app.vue中留坑&lt;router-view&gt;&lt;/router-view&gt;，路由切换时切换的是&lt;router-view&gt;挂载的组件，其他内容不会改变这里的 &lt;router-view&gt; 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 &lt;router-view&gt; 123456789101112131415161718192021222324252627282930313233343536373839import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;import info from &apos;@/components/info&apos;import test from &apos;@/components/test&apos;import test2 from &apos;@/components/test2&apos;import test3 from &apos;@/components/test3&apos;Vue.use(Router)export default new Router(&#123; mode: &apos;history&apos;,//没写这个可能会不显示 routes: [ &#123; path: &apos;/&apos;, component: HelloWorld &#125;, &#123; path: &apos;/info/:id&apos;, name: &apos;infoName&apos;, component: info, children: [ &#123; path: &apos;test1&apos;, name: &apos;test1Name&apos;, component: test &#125;, &#123; path: &apos;test2&apos;, component: test2 &#125; ] &#125;, &#123; path: &apos;/test3&apos;, component: test3 &#125; ]&#125;) routes的参数解析 path：规定路由。 在配置文件里以冒号的形式设置参数可以用来传递参数123456&#123; path:&apos;/params/:newsId/:newsTitle&apos;, name: &apos;test&apos;, meta: &apos;hello&apos;, component:Params&#125; 在目标页面中可以直接用$route.params.newsId来获取参数 name:命名路由，可以通过name值跳转到指定路由1&lt;router-link :to=&quot;&#123; name: &apos;infoName&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; 或1router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;) 跳转到name是infoName到命名路由 meta:存一些其他信息 component：映射的组件 vue-router跳转vue-router有两种跳转页面的方式： 使用内置的&lt;router-link&gt;组件 使用router实例方法，如$route.push() router-link1&lt;router-link to=&quot;/info&quot;&gt;跳转到info页面&lt;/router-link&gt; router-link相当于a标签 router-link的一些属性 to指定要跳转的路径,也可以使用v-bind动态绑定，html5的history模式下会拦截点击 tag: 规定&lt;router-link&gt;渲染成什么标签 replace:不会留下history记录，不能使用后退键 active-class:路由匹配成功时会自动给当前元素设置一个名为router-link-active的class router实例的方法进行跳转 $router.push(locationObj, onCompleteCallback, onAbortCallback):类似于window.location.href $router.replace(locationObj, onCompleteCallback, onAbortCallback):不会向history添加历史记录，而是替换掉当前的history $router.go(n)：类似于window.history.go()，前进后退多少步 router.push(locationObj, onCompleteCallback, onAbortCallback):在 router.push 或 router.replace 中提供 onCompleteCallback 和 onAbortCallback 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。 Vue Router 的导航方法 (push、 replace、 go) 在各类路由模式 (history、 hash 和 abstract) 下表现一致 $router与$route$router是VueRouter实例,代表路由器http://localhost:8080/info/3/?order=1234 $route是当前路由的对象下面是/info路由的$router打印出来的结果，有属性fullPath、path、name、params、query等http://localhost:8080/info/3/?order=1234 嵌套路由 形式：/user/foo/profile、/user/foo/posts 要注意，以 / 开头的嵌套路径会被当作根路径。嵌套路由的path内路径不要以／开头 将嵌套的路由放在children数组中,嵌套路由的页面显示在它的父级组件的 &lt;router-view&gt;中1234567891011121314151617181920const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;profile&apos;, component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;posts&apos;, component: UserPosts &#125; ] &#125; ]&#125;) 命名视图同时展示多个视图时用，比如侧导航和main内容区同时显示，这时可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default123&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; 重定向可参考：vue-router重定向链接“重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b 别名别名就是访问别名到url和访问原本的url产生的效果是一样的/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样 路由组件传参上面已经提到过路由通过url中/info/:id这种传参方法，在目标页面用$route.params.id获取参数，这样做法缺点是增加了代码耦合性通过 props 可以实现解耦12345678910111213141516const User = &#123; props: [&apos;id&apos;], template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &apos;/user/:id&apos;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 如果 props 被设置为 true，route.params 将会被设置为组件属性 设置404页面当所有路由规则都没有匹配到时显示123456const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;*&apos;, component: NotFoundComponent &#125; ]&#125;) 导航守卫导航：表示路由正在发生变化的这个过程在路由发生变化的过程中设置了几个钩子，在钩子中可以干一些事，比如路由改变前改变页面的title钩子： beforeEach:全局前置钩子，路由即将改变前，设置页面标题可以在该钩子内完成 to:即将进入的目标的路由对象(目标的$route) from:即将离开的路由对象 next:调用该方法后才能进入下一个钩子,一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) afterEach:它是一个全局后置钩子，全局后置不会接受 next 函数也不会改变导航本身： 123router.afterEach((to, from) =&gt; &#123; // ...&#125;) 完整的导航解析流程： 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 过度效果&lt;router-view&gt; 是基本的动态组件，所以我们可以用 &lt;transition&gt; 组件给它添加一些过渡效果：123&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 通过name属性还可以定义不同的动画效果 路由懒加载1() =&gt; import(&apos;./Foo.vue&apos;) 把组件按组分块:有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name。123const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Foo.vue&apos;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Bar.vue&apos;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Baz.vue&apos;) 比较好的文章：vue-router 源码：前端路由前端路由简介以及vue-router实现原理vue-router详解vue-router官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue中的slot小结]]></title>
      <url>%2F2018%2Fvue%E4%B8%AD%E7%9A%84slot%E5%B0%8F%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC] 要点： 内容是由父组件决定的 父组件中的内容将替代子组件中&lt;slot&gt;标签及它的内容 子组件slot定义处可以规定显示顺序等 作用域插槽 显示样式父组件决定，内容可以由子组件插槽中绑定 子组件中通过v-bind绑定属性将子组件的内容传递过来，在父组件中通过slot-scope接受子组件的内容 写在前面vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和methods，data，computed等常用选项在使用频率、使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了vue的说明文档。 实际上，插槽的概念很简单，下面通过分三部分来讲。这三部分也是按照vue说明文档的顺序来写的。 进入这三部分之前，先让还没接触过插槽的同学对什么是插槽有一个简单的概念：插槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。 实际上，一个slot最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。 由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为非插槽模板和插槽模板两大类。 非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。 作用域父组件模版的内容是在父组件作用域内编译，子组件模版内容是在子组件作用域内编译，也就是说父子组件模版内的变量是对应各自的变量。 单个插槽 | 默认插槽 | 匿名插槽首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。 单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。 下面通过一个例子来展示。 父组件： 123456789101112131415&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;child&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单4&lt;/span&gt; &lt;span&gt;菜单5&lt;/span&gt; &lt;span&gt;菜单6&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 子组件： 123456&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。 12345678&lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单4&lt;/span&gt; &lt;span&gt;菜单5&lt;/span&gt; &lt;span&gt;菜单6&lt;/span&gt;&lt;/div&gt; 如果子组件中没有默认的匿名slot，那么父组件中多余内容片段将会被抛弃。 具名插槽匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。 父组件： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;child&gt; &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单4&lt;/span&gt; &lt;span&gt;菜单5&lt;/span&gt; &lt;span&gt;菜单6&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt; &lt;span&gt;菜单-1&lt;/span&gt; &lt;span&gt;菜单-2&lt;/span&gt; &lt;span&gt;菜单-3&lt;/span&gt; &lt;span&gt;菜单-4&lt;/span&gt; &lt;span&gt;菜单-5&lt;/span&gt; &lt;span&gt;菜单-6&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单-&gt;1&lt;/span&gt; &lt;span&gt;菜单-&gt;2&lt;/span&gt; &lt;span&gt;菜单-&gt;3&lt;/span&gt; &lt;span&gt;菜单-&gt;4&lt;/span&gt; &lt;span&gt;菜单-&gt;5&lt;/span&gt; &lt;span&gt;菜单-&gt;6&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 子组件： 1234567891011&lt;template&gt; &lt;div class=&quot;child&quot;&gt; // 具名插槽 &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; // 具名插槽 &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt; // 匿名插槽 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。 作用域插槽 | 带数据的插槽最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写 但是作用域插槽要求，在slot属性上面绑定数据。子组件中通过v-bind绑定属性将子组件的内容传递过来，在父组件中通过slot-scope接受子组件的内容也就是你得写成大概下面这个样子。子组件：123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;child1&quot;&gt; &lt;div class=&quot;child2&quot; v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &lt;slot :ChildProp=&quot;todo&quot;&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data: function()&#123; return &#123; todos: [ &#123; id: 1, name: &apos;wang&apos;&#125;, &#123; id: 2, name: &apos;wang2&apos;&#125;, &#123; id: 3, name: &apos;wang3&apos;&#125;, &#123; id: 4, name: &apos;wang4&apos;&#125;, &#123; id: 5, name: &apos;wang5&apos;&#125; ] &#125; &#125;,&#125;&lt;/script&gt; 父组件：12345678910111213&lt;template&gt; &lt;div class=&quot;parent1&quot;&gt; &lt;todo-list&gt; &lt;template slot-scope=&quot;&#123;ChildProp&#125;&quot;&gt; &lt;div class=&quot;parent2&quot;&gt; &lt;span&gt;&#123;&#123;ChildProp.name&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/todo-list&gt; &lt;/div&gt;&lt;/template&gt;//js中import子组件并命名为TodoList 父组件接收数据用了解构，因为子组件中用了v-for，数据是从数组中一条一条传过来的，每条数据的结构的样子是{ &quot;ChildProp&quot;: { &quot;id&quot;: 1, &quot;name&quot;: &quot;wang&quot; } }显示结果： 正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。 我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。 下面是从子组件传一个数组过来的例子： 子组件： 12345678910111213141516&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; // 作用域插槽 &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; data: function()&#123; return &#123; data: [&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wanwu&apos;,&apos;zhaoliu&apos;,&apos;tianqi&apos;,&apos;xiaoba&apos;] &#125; &#125;&#125; 父组件： 1234567891011121314&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;!--第一次使用：用flex展示数据--&gt; &lt;child&gt; &lt;template slot-scope=&quot;user&quot;&gt; &lt;div&gt; &lt;span v-for=&quot;item in user.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/child&gt;&lt;/template&gt; 父组件中接收到数据存在user中，user的数据结构是{ &quot;data&quot;: [ &quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wanwu&quot;, &quot;zhaoliu&quot;, &quot;tianqi&quot;, &quot;xiaoba&quot; ] } 访问slotvue2种提供了访问slot分发内容的方法$slot子组件中通过this.$slot.AName可以访问某个具名slot，通过this.$slot.default包含了所有没有包含在具名slot中的节点。 参考：https://juejin.im/post/5a69ece0f265da3e5a5777ed]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于电影的奇思异想]]></title>
      <url>%2F2018%2F%E5%85%B3%E4%BA%8E%E7%94%B5%E5%BD%B1%E7%9A%84%E5%A5%87%E6%80%9D%E5%BC%82%E6%83%B3.html</url>
      <content type="text"><![CDATA[上午写论文的时候听到英雄联盟的歌曲，突然有个奇思妙想。 以后的动画片或者电影可不可以也像LOL这样，创建每个角色和场景，然后导演可像玩游戏一样控制人物的移动、动作，然后后期配音，这样就构成了一部电影，打斗技能也能通过编程设定。 假如有这样一个开放的平台，开发者可以在这个平台创建各种风格的基本人物，其他人也能引用这些基本角色或进行二次加工，人物角色的可复用可节省大量人力物力，提供重复利用率 或者以后技术更发达了，可以创建出逼真的像明星一样的人物造型，那以后拍电影都不需要演员了，普通大众也可以随心所欲的拍出自己的电影，使得拍电影更大众化。 丰富人物角色的动作、演技，使得更逼真是这样一个平台的最大难点。感觉如果有这样一个平台的话盈利点也非常多。 如果真能实现一个这种平台，感觉又会是一家迅速串红的公司，从自媒体串红可以看出，我们这种屁民还是很想把自己内心的想法展示给全世界看的。 以上是个人一些关于电影与可编程的一些奇怪想法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中数组API的汇总]]></title>
      <url>%2F2018%2FJS%E4%B8%AD%E6%95%B0%E7%BB%84API%E7%9A%84%E6%B1%87%E6%80%BB.html</url>
      <content type="text"><![CDATA[[TOC]instanceof、Array.isArray()toString()、valueOf()push()、unshift()、concat()shift()、pop()indexOf、lastIndexOf、every()、filter()、forEach()、map()、some()splice()增加或删除、slice()reverse()、sort()reduce() 关于这些api是否改变原数组的总结见另外我的另外一篇文章 是否改变原数组的常用方法归纳 检测数组instanceof1value instanceof Array 问题在于它假定只有一个全局执行环境，如果网页中包含多个框架，那就存在两个以上的不同版本的Array构造函数 Array.isArray()1Array.isArray(value) 解决instanceof存在的问题，最终确定某个值是否是数组 转换方法所有对象都具有toString和valueOf方法 toString()数组调用toString()方法会返回由数组每项的字符串形式拼接而成的一个以逗号分隔的字符串12var colors=[&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];colors.toString() //red,blue,green valueOf()12var colors=[&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];colors.valueOf() //red,blue,green 增加项push()在数组末尾添加项，会改变原数组返回值：数组的新长度12var colors=[&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];colors.push(&quot;white&quot;, &quot;black&quot;); unshift()在数组头部添加元素，会改变数组返回值：数组的新长度 concat()合并两个或多个数组,不改变原数组返回值：拼合后的新的数组1arrayObject.concat(arrayX,arrayX,......,arrayX) jion() 删shift()将第一个元素删除，空即为undefined。会改变原数组返回值：删除元素 pop()删除数组的最后一项返回值：删除的元素 查indexOfindexOf(value,index)：其中index(起点位置)是可选的。从数组开头开始查找，执行的是严格相等查找(===)返回值：第一个找到的值的索引，如果没找到返回-1 lastIndexOflastIndexOf(value,index)：其中index(起点位置)是可选的。从数组末尾开始向前查找，执行的是严格相等查找(===)返回值：第一个找到的值的索引，如果没找到返回-1 every() 不改变原数组 语法：array.every(function(currentValue,index,arr), thisValue) 原理说明：对数组的每一项都运行给定的函数，即把每一项都依次传入函数，如果该函数对数组的每一项都返回true，则返回true 参数说明： currentValue：数组传入的当前项 index：当前项在数组中的索引 arr：当前元素所属的数组，即array thisValue：绑定this 返回值：true/false 示例：12345var arr=[1,2,3,4,5,4];var everyResult=arr.every(function(val, index, array)&#123; return val&gt;0;&#125;);console.log(everyResult); // true filter() 不改变原数组 语法：array.filter(function(currentValue,index,arr), thisValue) 原理说明：对数组的每一项都运行给定的函数，即把每一项都依次传入函数，返回该函数返回true的项组成的数组 参数说明： currentValue：数组传入的当前项 index：当前项在数组中的索引 arr：当前元素所属的数组，即array thisValue：绑定this 返回值：函数返回为true的项组成的新数组 示例：12345var arr=[1,2,3,4,5,4];var filterResult=arr.filter(function(val, index, array)&#123; return val&gt;2;&#125;);console.log(everyResult); // [3,4,5,4] forEach() 不改变原数组 语法：array.forEach(function(currentValue,index,arr), thisValue) 原理说明：对数组的每一项都运行给定的函数，即把每一项都依次传入函数，该方法没有返回值 参数说明： currentValue：数组传入的当前项 index：当前项在数组中的索引 arr：当前元素所属的数组，即array thisValue：绑定this 返回值：无 示例：12345var arr=[1,2,3,4,5,4];var sum=0;var filterResult=arr.forEach(function(val, index, array)&#123; sum += item;&#125;); map() 不改变原数组 语法：array.map(function(currentValue,index,arr), thisValue) 原理说明：对数组的每一项都运行给定的函数，即把每一项都依次传入函数，该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值，没处理也保留在新数组中 参数说明： currentValue：数组传入的当前项 index：当前项在数组中的索引 arr：当前元素所属的数组，即array thisValue：绑定this 返回值：返回一个新数组，是由每次函数调用的结果组成的数组 some() 不改变原数组 语法：array.map(function(currentValue,index,arr), thisValue) 原理说明：对数组的每一项都运行给定的函数，即把每一项都依次传入函数，数组的任意一项返回true，则返回true 参数说明： currentValue：数组传入的当前项 index：当前项在数组中的索引 arr：当前元素所属的数组，即array thisValue：绑定this 返回值：true/false 改splice()增加或删除 会改变原数组 语法：array.splice(index,howmany,item1,.....,itemX) 功能：删除数组中元素或向数组中插入元素 参数说明： index：从何处开始增加或删除 howmany：删除多少项 item1,…..,itemX：添加的元素 返回值：返回被删除的元素组成的数组，如果是增加的话则没有返回值 删除： splice(从何处开始删index，项数) 插入：splice(插入到谁后面index，0，要增加的元素) slice() 不改变原数组 语法：array.slice(start, end) 功能：提取数组中元素生成新数组 参数说明： start：从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。-1 指最后一个元素 end：在end之前结束选取，不包含end 返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的元素 数组排序reverse()sort()sort() 方法可以接受一个 方法为参数 ，这个方法有两个参数。分别代表每次排序比较时的两个数组项。sort()排序时每次比较两个数组项都回执行这个参数，并把两个比较的数组项作为参数传递 给这个函数。当函数返回值为1的时候就交换两个数组项的顺序，否则就不交换。 归并reduce() 【持续更新中…】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】数组Array的扩展]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91%E6%95%B0%E7%BB%84Array%E7%9A%84%E6%89%A9%E5%B1%95.html</url>
      <content type="text"><![CDATA[[TOC]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转】前端性能优化之加载技术]]></title>
      <url>%2F2018%2F%E3%80%90%E8%BD%AC%E3%80%91%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF.html</url>
      <content type="text"><![CDATA[[TOC] 转自：https://juejin.im/post/59b73ef75188253db70acdb5 前端性能优化之加载技术在这个前端用户体验越来越重要的时代，你的页面稍微有点卡顿，都难以挽留用户。而作为一名有追求的前端，势必要力所能及地优化我们前端页面的性能。今天，就来谈一谈那些前端性能优化的加载技术，利用这些技术可以很好地提高网站的响应速度和用户体验。 页面渲染在理解真正的优化技术之前，我们需要先了解为什么需要优化？这得从浏览器的渲染引擎谈起。浏览器从获取HTML文档开始，就进入了渲染引擎的工作阶段，其目的是将网页的内容显示在浏览器屏幕上。大体可以描述为从解析HTML内容，构造DOM节点再到DOM元素布局定位最后再绘制DOM元素的这样一个过程。更加详细的内容可以参考How browser works, 要看中文的童鞋可以看这篇译文。 在页面渲染的这样一个过程中，有一个关键点是如果在解析内容的过程中遇到了脚本标签，如：&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;，浏览器就会暂停内容的解析，转而开始下载脚本。并且只有等脚本下载完并执行结束后，渲染引擎才会继续解析。那么这样一来，页面显示的时间必然会被延长。因此我们需要优化的点就是尽可能地让页面更早地被渲染出来。 脚本加载的优化要解决上面说到的脚本加载问题，通常有三种解决方案：将脚本放在HTML末尾、动态加载脚本以及异步加载脚本。最常用的应该就是将所有脚本放置在HTML文档的末尾了。这应该是每个前端刚入门时，被教的最多的。对于这个方法，这里就不多做介绍，直接上重头戏。 动态加载所谓动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。 123456function loadJS(src) &#123; const script = document.createElement(&apos;script&apos;); script.src = src; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);&#125;loadJS(&apos;http://example.com/scq000.js&apos;); 异步加载我们都知道，在计算机程序中同步的模式会产生阻塞问题。所以为了解决同步解析脚本会阻塞浏览器渲染的问题，采用异步加载脚本就成为了一种好的选择。利用脚本的async和defer属性就可以实现这种需求： 12&lt;script type=&quot;text/javascript&quot; src=&quot;./a.js&quot; async&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./b.js&quot; defer&gt;&lt;/script&gt; 虽然利用了这两个属性的script标签都可以实现异步加载，同时不阻塞脚本解析。但是使用async属性的脚本执行顺序是不能得到保证的。而使用defer属性的脚本执行顺序可以得到保证。另一方面，defer属性是在html文档解析完成后，DOMContentLoaded事件之前就会执行js。async一旦加载完js后就会马上执行，最迟不超过window.onload事件。所以，如果脚本没有操作DOM等元素，或者与DOM时候加载完成无关，直接使用async脚本就好。如果需要DOM，就只能使用defer了。 这里介绍的两种方法在实际运用过程中需要权衡一下的，渲染速度变快也就意味着脚本加载时间会变长。 解决异步加载脚本的问题上面介绍的异步加载脚本并不是十分完美的。如何处理加载过程中这些脚本的互相依赖关系，就成了实现异步加载过程中所需要考虑的问题。一方面，对于页面中那些独立的脚本，如用户统计等插件就可以放心大胆地使用异步加载。而另一方面，对于那些确实需要处理依赖关系的脚本，业界已经有很成熟的解决方案了。如采用AMD规范的RequireJS,甚至有采用了hack技术（通过欺骗浏览器下载但不执行脚本)的labjs（已过时)。如果你熟悉promise的话，就知道这是在JS中处理异步的一种强有力的工具。下面以promise技术来实现处理异步脚本加载过程中de的依赖问题： 1234567891011121314151617181920212223242526272829// 执行脚本function exec(src) &#123; const script = document.createElement(&apos;script&apos;); script.src = src; // 返回一个独立的promise return new Promise((resolve, reject) =&gt; &#123; var done = false; script.onload = script.onreadystatechange = () =&gt; &#123; if (!done &amp;&amp; (!script.readyState || script.readyState === &quot;loaded&quot; || script.readyState === &quot;complete&quot;)) &#123; done = true; // 避免内存泄漏 script.onload = script.onreadystatechange = null; resolve(script); &#125; &#125; script.onerror = reject; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &#125;);&#125;function asyncLoadJS(dependencies) &#123; return Promise.all(dependencies.map(exec));&#125;asyncLoadJS([&apos;https://code.jquery.com/jquery-2.2.1.js&apos;, &apos;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&apos;]).then(() =&gt; console.log(&apos;all done&apos;)); 可以看到，我们针对每个脚本依赖都会创建一个promise对象来管理其状态。采用动态插入脚本的方式来管理脚本，然后利用脚本onload和onreadystatechange(兼容性处理)事件来监听脚本是否加载完成。一旦加载完毕，就会触发promise的resovle方法。最后，针对依赖的处理，是promise的all方法，这个方法只有在所有promise对象都resolved的时候才会触发resolve方法，这样一来，我们就可以确保在执行回调之前，所有依赖的脚本都已经加载并执行完毕。 懒加载(lazyload)懒加载是一种按需加载的方式，也通常被称为延迟加载。主要思想是通过延迟相关资源的加载，从而提高页面的加载和响应速度。在这里主要介绍两种实现懒加载的技术：虚拟代理技术以及惰性初始化技术。 虚拟代理加载所谓虚拟代理加载，即为真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。 12345678910// 页面中的图片url事先先存在其data-src属性上const lazyLoadImg = function() &#123; const images = document.getElementsByTagName(&apos;img&apos;); for(let i = 0; i &lt; images.length; i++) &#123; if(images[i].getAttribute(&apos;data-src&apos;)) &#123; images[i].setAttribute(&apos;src&apos;, images[i].getAttribute(&apos;data-src&apos;)); images[i].onload = () =&gt; images[i].removeAttribute(&apos;data-src&apos;); &#125; &#125;&#125; 惰性初始化惰性初始模式是在程序设计过程中常用的一种设计模式。顾名思义，这个模式就是一种将代码初始化的时机推迟（特别是那些初始化消耗较大的资源），从而来提升性能的技术。 jQuery中大名鼎鼎的ready方法就用到了这项技术，其目的是为了在页面DOM元素加载完成后就可以做相应的操作，而不需要等待所有资源加载完毕后。与浏览器中原生的onload事件相比，可以更加提前地介入对DOM的干涉。当页面中包含大量图片等资源时，这个方法就显出它的好处了。在jQuery内部的实现原理上，它会设置一个标志位来判断页面是否加载完毕，如果没有加载完成，会将要执行的函数缓存起来。当页面加载完毕后，再一一执行。这样一来，就将原本应该马上执行的代码，延迟到页面加载完毕后再执行。感兴趣的可以去阅读这一部分的源码，里面还包括了浏览器兼容等处理。 选择时机选择时机：比较常见的两种 滚动条监听 事件回调（需要用户交互的地方） 当然，你也可以根据具体的业务场景选择延迟加载的时机。 滚动条监听滚动条监听，常常用在大型图片流等场景下。通过对用户滚动结束的区域进行计算，从而只加载目标区域中的资源。这样就可以实现节流的目的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 简单的节流函数function throttle(func, wait, mustRun) &#123; var timeout, startTime = new Date(); return function() &#123; var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun)&#123; func.apply(context,args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125;else&#123; timeout = setTimeout(func, wait); &#125; &#125;;&#125;;// 判断元素是否在可视范围内function elementInViewport(element) &#123; const rect = element.getBoundingClientRect(); return (rect.top &gt;= 0 &amp;&amp; rect.left &gt;= 0 &amp;&amp; rect.top &lt;= (window.innerHeight || document.documentElement.clientHeight));&#125;function lazyLoadImgs() &#123; const count = 0; return function() &#123; [].slice.call(images, count).forEach(image =&gt; &#123; if(elementInViewport(elementInViewport(image))) &#123; image.setAttribute(&apos;src&apos;, image.getAttribute(&apos;data-src&apos;)); count++; &#125; &#125;); &#125;&#125;const images = document.getElementByTagName(&apos;img&apos;);// 采用了节流函数, 加载图片window.addEventListener(&apos;scroll&apos;,throttle(lazyLoadImgs(images),500,1000)); 事件回调这种场景就是那些需要用户交互的地方，如点击加载更多之类的。这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起ajax请求来获取资源。比较简单，在此不再赘述。 利用webpack实现脚本加载优化现如今，对于大型项目大家都会用上打包工具。现代化的工具使得我们不必再写那些又长又难懂的代码。针对懒加载，webpack也提供了十分友好的支持。这里主要介绍两种方式。 import()方法我们知道，在原生es6的语法中，提供了import和export的方式来管理模块。而其import关键字是被设置成静态的，因此不支持动态绑定。不过在es6的stage 3规范中，引入了一个新的方法import()使得动态加载模块成为可能。所以，你可以在项目中使用这样的代码： 12345678910111213141516$(&apos;#button&apos;).click(function() &#123; import(&apos;./dialog.js&apos;) .then(dialog =&gt; &#123; //do something &#125;) .catch(err =&gt; &#123; console.log(&apos;模块加载错误&apos;); &#125;);&#125;);//或者更优雅的写法$(&apos;#button&apos;).click(async function() &#123; const dialog = await import(&apos;./dialog.js&apos;); //do something with dialog&#125;); 由于该语法是基于promise的，所以如果需要兼容旧浏览器，请确保在项目中使用es6-promise或者promise-polyfill。同时，如果使用的是babel，需要添加syntax-dynamic-import插件。 require.ensurerequire.ensure与import()类似，同样也是基于promise的异步加载模块的一种方法。这是在webpack 1.x时代官方提供的懒加载方案。现在，已经被import()语法取代了。为了文章的完整性，这里也做一些介绍。 在webpack编译过程中，会静态地解析require.ensure中的模块，并将其添加到一个单独的chunk中，从而实现代码的按需加载。 语法如下： 1require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String) 一个十分常见的例子是在写单页面应用的时候，使用该技术实现基于不同路由的按需加载： 123const routes = [ &#123;path: &apos;/comment&apos;, component: r =&gt; require.ensure([], r(require(&apos;./Comment&apos;)), &apos;comment&apos;)&#125;]; 预加载首屏加载的问题解决后，用户在具体的页面使用过程中的体验也很重要。如果能够通过预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更加良好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。因此，“预加载”的技术就闪亮登场了。 preload规范preload 是w3c新出的一个标准。利用link的rel属性来声明相关“proload”，从而实现预加载的目的。就像这样： 1&lt;link rel=&quot;preload&quot; href=&quot;example.js&quot; as=&quot;script&quot;&gt; 其中rel属性是用来告知浏览器启用preload功能，而as属性是用来明确需要预加载资源的类型，这个资源类型不仅仅包括js脚本(script)，还可以是图片(image)，css(style)，视频(media)等等。浏览器检测到这个属性后，就会预先加载资源。 这个规范目前兼容性方面还不是很好，所以可以先稍微了解一下。webpack现在也已经有相关的插件，如果感兴趣的话，请移步preload-webpack-plugin。对于更加详细的技术细节，这里推荐一篇博客www.smashingmagazine.com/2016/02/pre…。 DNS Prefetch 预解析还有一个可以优化网页速度的方式是利用dns的预解析技术。同preload类似，DNS Prefetch在网络层面上优化了资源加载的速度。我们知道，针对DNS的前端优化，主要分为减少DNS的请求次数，还有就是进行DNS预先获取。DNS prefetch就是为了实现这后者。其用法也很简单，只要在link标签上加上对应的属性就行了。 12&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; /* 这是用来告知浏览器当前页面要做DNS预解析 */&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt; 在支持该标准的浏览器上，会自动对链接中的地址域名做DNS解析缓存。不过，像Goolge、火狐这样的现代浏览器即使不设置这个属性，也能在后台做自动预解析。如果你的页面中需要大量访问不同域名的资源，可以利用这项技术加快资源的获取，从而获得更好的用户体验。需要注意的是，DNS预解析虽好，但是也不能滥用。如果对多页面重复DNS预解析，会增加DNS的查询次数。 总结通常对于大型应用来说，完整加载所有javascript代码是十分耗时的工作。因此，通常会将JavaScript分为两个部分（一部分是渲染初始化页面所必须的，另一部分则是剩下的脚本）来进行加载。这样就可以尽可能快速地渲染出网页。通过监听onload事件，可以很好地控制回调的时机，同时采用异步加载等技术能够同时并行加载多个脚本，从而大大提高最终页面的渲染速度。最好是把在onload事件之前执行的代码拆分成一个单独的文件。当然，在处理脚本加载这一过程中还存在着几个问题：1.如何找到需要拆分的代码？ 2 怎样处理竞争状态 ？3.如何延迟加载其余部分的代码？希望这篇文章能够给你启发！对于文中有错漏之处，欢迎指出。鉴于本人水平有限，也欢迎大家来多多交流。 参考资料《Javascript性能优化》 bubkoo.com/2015/11/19/… 2ality.com/2017/01/imp… segmentfault.com/a/119000000… perishablepress.com/3-ways-prel… www.youtube.com/watch?v=wKC…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器加载、解析、渲染以及优化]]></title>
      <url>%2F2018%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E3%80%81%E8%A7%A3%E6%9E%90%E3%80%81%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96.html</url>
      <content type="text"><![CDATA[为什么要了解浏览器加载、解析、渲染这个过程？ 了解浏览器如何进行加载，我们可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。 了解浏览器如何进行解析，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。 了解浏览器如何进行渲染，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少”重绘“”重新布局“的消耗。这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一边解析，一边渲染的工作现象。 [TOC] 举例 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 浏览器开始载入html代码，发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件； 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 浏览器继续载入html中&lt;body&gt;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行Javascript代码的&lt;script&gt;标签，赶快运行它； Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个&lt;div&gt; （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了&lt;/html&gt;的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径； 浏览器召集了在座的各位&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 一、浏览器加载(获取资源的过程) 关于加载顺序：当浏览器获得一个html文件时，会”自上而下“加载，并在加载过程中进行解析渲染 加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。这是异步请求，并不会影响html文档进行加载，但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。 虽然css文件的加载不影响js文件的加载，但是却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。 二、浏览器解析 过程:DOM树构建和CSSOM构建是同步进行的，直到CSSOM构建完才开始构建渲染树，这中间会存在一些阻塞 默认情况下，CSS 被视为阻塞渲染的资源(不阻塞DOM树构建)，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕 存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建 CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行 无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），不会阻塞DOM构建，DOM解析（Parsing）会正常进行。不论是内联还是外链JavaScript都会阻塞后续DOM解析（Parsing），当然后续DOM的渲染（Rendering）也被阻塞了。 1、DOM树构建 外链JS情况下，DOM树是增量构建的，虽然DOM被阻塞了，但是JS外链前的DOM可以正常解析和渲染 内联JS代码块会阻塞渲染线程，直到JS执行完才开始渲染例子： 【JS外链】结果是立即显示hello，外链JS加载并执行后显示world 12345&lt;body&gt; hello &lt;script src=&quot;./a.js&quot;&gt; world&lt;/body&gt; 【内联JS块】一直白屏，执行完js后显示hello world1234567&lt;body&gt; hello &lt;script&gt; //js代码 &lt;/script&gt; world&lt;/body&gt; 2、CSSOM树构建要等到CSSOM树构建完后才能渲染 3、render树构建【未完待续】找了网上很多博客，感觉没有讲的全面的，整个过程各种阻塞情况的都有考虑的暂时没看到 【注】部分转自：https://www.jianshu.com/p/e141d1543143http://www.cnblogs.com/lhb25/p/how-browsers-work.html#Webkit_CSS_parserhttps://blog.csdn.net/liaozhongping/article/details/51028705https://harttle.land/2016/11/26/static-dom-render-blocking.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 3D技术]]></title>
      <url>%2F2018%2FHTML5%203D%E6%8A%80%E6%9C%AF.html</url>
      <content type="text"><![CDATA[[TOC]最近发现前端一个很有意思的方向， 3D和可视化 HTML5，不只是看上去很美：打造最美3D机房！ 上面是最近参加360前端星组员推荐的一个比较有意思的HTML5写的一个3D场景的页面，可以模拟真实的环境下的各种动作 如果以后的网站都成为3D的了，那样网页的功能就将更丰富，你甚至可以把自己的家搬到3D页面里，如果与物联网相结合的话，你就可以用鼠标点击按钮来控制家里的智能家电了，感觉这是个很有创意的方向 最近还接触到了用D3.js和echarts做可视化，有时间也可以了解了解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】函数扩展]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95.html</url>
      <content type="text"><![CDATA[思维导图 [TOC]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】数值Number扩展]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91%E6%95%B0%E5%80%BCNumber%E6%89%A9%E5%B1%95.html</url>
      <content type="text"><![CDATA[[TOC]ES6在数值Number方面改动： 新增二进制、八进制表示法 新增判断api 1、Number.isFinite() 2、Number.isNaN() 3、Number.isInterger() 4、Number.isSafeInterger() Math扩展 Math.trunc() Math.sign() 其他常用 新增二进制、八进制表示法ES6 提供了二进制和八进制数值的新的写法 二进制：用前缀0b（或0B）表示，开头第一个是零。 0b0111 ===7 // true 八进制：用前缀0o（或0O）表示，开头第一个是零。0o767 === 503 // true 新增判断api1、Number.isFinite()(1)与传统的全局方法isfIinite()区别在于：传统方法是先调用Number()强制将非数值转化成数值再判断，ES6中Number.isFinite()不会自动做转化，对于非数值一律返回false(2)ES5实现：12345678910111213141516//ES5实现Number.isFinite()(function (global) &#123; let globalIsFinite=global.isFinite;//传统的全局isFinite //把isFinite绑定到Number原型上 Object.defineProperty(Number,&apos;isFinite&apos;,&#123; value: function isFinite(value) &#123; return typeof value ===&apos;number&apos; &amp;&amp; globalIsFinite(value);//必须是number &amp;&amp; 满足传统的isFinite() &#125;, configurable: true, enumerable: false, writable: true &#125;)&#125;)(this)console.log(Number.isFinite(&apos;24&apos;)) //false 2、Number.isNaN()(1)与传统的全局方法isNaN()区别在于：传统方法是先调用Number()强制将非数值转化成数值再判断，ES6中Number.isNaN()不会自动做转化，对于非NaN一律返回false(2)ES5实现：1234567891011121314//ES5实现Number.isNaN()(function (global) &#123; let globalIsNaN=global.isNaN; Object.defineProperty(Number,&apos;isNaN&apos;,&#123; value: function isNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; globalIsNaN(value) &#125;, configurable: true, enumerable: false, writable: true &#125;) &#125;)(this) console.log(Number.isNaN(&apos;NaN&apos;))//false 3、Number.isInterger()判断一个值是否为整数，注意同一个整数用整数和浮点数是同样的存储方法123Number.isInterger(3) //trueNumber.isInterger(3.0)//trueNumber.isInterger(3.1) //false 4、Number.isSafeInterger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内，非数值不会自动转换。12345678Number.isSafeInteger(&apos;a&apos;) // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // true 整数Number.isSafeInteger(1.2) // false 浮点数 Math扩展Math.trunc() 用于去除一个数的小数部分，返回整数部分 12Math.trunc(4.1) //4Math.trunc(-4.1) //-4 对于非数值，Math.trunc内部使用Number方法将其先转为数值 对于空值和无法截取整数的值，返回NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。123Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。它会返回五种值:参数为正数，返回+1；参数为负数，返回-1；参数为 0，返回0；参数为-0，返回-0;其他值，返回NaN。 其他常用1、指数运算符：ES2016 新增了一个指数运算符**12//2的3次方表示2 ** 3 // 8 a**=b表示a的b次方]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】字符串的扩展]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html</url>
      <content type="text"><![CDATA[ES6字符串扩展脑图 ES6在字符串变动了编码规则、新增了一些位置相关和查找字符串相关的api、新增模板字符串和标签模板 [TOC] 编码的变化1、ES5中字符是用UTF-16表示，即1字符=16位=2字节，范围是0xFFFF ES6中允许用4字节来表示1字符，即32位 注意：这里将的是字符的编码，和JS中最大存储值不是一个概念，JS中所有数字都保存成64位float类型，正式的精确程度只能到53位二进制，超出这个范围的JS无法精确表示 2、新增码点相关api(1)codePointAt(index)返回某个字符的码点：ES5的字符一般用2字节存储，ES6支持4字节的字符表示法，四字节的用codePointAt()读取整个字符，返回字符的码点str.codePointAt(0)表示字符串str第一个字符,返回 32 位的 UTF-16 字符的码点(2)String.fromCodePoint(码点) 将码点转换成字符：支持4字节的 新增api1、与位置相关api(1)at(index)返回index下标对应的字符：ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。 (2)for...of字符串遍历：123456for (let codePoint of &apos;foo&apos;) &#123; console.log(codePoint)&#125;// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; (3)normalize()：用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化 2、新增查询字符包含与否的apiES5里只有indexOf()可以来确定一个字符串是否包含在另一个字符串中，ES6新增了3中方法(1)includes()：返回true/false，表示是否找到了参数字符串(2)startWith()：返回true/false，表示参数字符串是否是在源字符串的头部(3)endWith()：返回true/false，表示参数字符串是否是在源字符串的尾部 4、新增修改字符串的api(1)str.repeat(次数)【不改变原字符串】；返回一个新字符串，表示将原字符串重复n次(2)padStart()与padEnd()：补全字符串到规定的长度，这是ES2017新增的strSource.padStart(长度，“用来补全的字符串”)(3)matchAll()：matchAll方法返回一个正则表达式在当前字符串的所有匹配 模板字符串1、模板字符串用反引号包裹起来2、模板字符串中的变量用${变量或表达式或调用函数}表示3、可以在模板字符串后用.trim()方法去掉换行、空格4、模板字符串可以嵌套5、使用&lt;%= … %&gt;输出 JavaScript 表达式1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 标签模板 标签模板不是模板，它是函数的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分,tag函数的其他参数，都是模板字符串各个变量被替换后的。12345let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】解构]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91%E8%A7%A3%E6%9E%84.html</url>
      <content type="text"><![CDATA[解构的本质是模式匹配，只要等号左右两边的模式相同，左边的变量就会被赋予对应的值解构ES5实现：1234'use strict';var obj=&#123; foo: "aaa", bar: "bbb"&#125;;var bar=obj.foo;var foo=obj.bar; 脑图结构：http://naotu.baidu.com/file/9e48bcf4bbd766715f3c64d5cc790174?token=313fa87a66f621d0 [TOC] 解构 模式：变量其中模式是原来对象中存在的属性名，变量是要赋值的新变量名，如果模式和新的变量名一样有则省略变量名 限定范围：只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值， 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。1、数组解构可以用数组下标作为模式 [a, b, c] = [1, 2, 3] ; let {0:first2,[arr.length-1]:last}=arr; 2、对象解构1let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 如果要另起变量名：1let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;; 将解构的值放入数组：1234let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;); 3、字符串解构字符串被转换成一个类似数组的对象12const [a,b,c,d,e]=&quot;hello&quot;//a是h，b是e，c是l，d是l，e是o 4、函数参数解构(1)参数是数组时在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 (2)参数是对象时1234567function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 5、数值和Boolen的解构解构时如果等号右边时数值和对象，则会先转换成对象 解构默认值默认值在被解构的对象的值是undefined时才生效如果一个成员不严格等于undefined，默认值是不会生效的，比如被解构对象的值是null，则默认值是不会生效的 数组解构默认值1234let [foo = true] = [];foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 对象解构默认值123var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5 函数解构默认值(1)给解构每个变量赋默认值一个个参数独立生效1234567function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] (2)给参数整体赋默认值在整个参数对象没有赋值的时候才生效12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] //生效 剩余项12let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let [firstC, ...restC] = colors;//restC是数组[&quot;green&quot;, &quot;blue&quot;] 使用剩余项进行克隆：123let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let [...restC] = colors;console.log(restC);//[&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] 普通解构与嵌套解构123456789/* 普通解构*/let &#123;name,age&#125;=obj;console.log(name+age); /* 嵌套解构*/let &#123;name,sex,skill:&#123;eat,frontend&#125;&#125;=obj;//这里的skill是模式console.log(name+' '+eat+' '+frontend)let &#123;skill:skills&#125;=obj;console.log(skills) 圆括号问题只有一种情况可以使用圆括号可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 要点： 也就是说新变量是已经声明过了的 非模式部分123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 绝对不能使用圆括号情况1、变量声明语句中1let [(b)]=[1,2,3];//报错 2、函数参数1function f([z,(x)]) &#123; return x; &#125;//报错 3、赋值语句的模式赋值语句的模式不能被包裹在圆括号中1[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];//p和x被包裹在圆括号中，报错 用途1、交换变量的值2、从函数返回多个值（感觉这个有点牵强，这不就是解构的基本用法吗，和函数没有啥重要关系吧）3、函数参数的定义：可以方便地将一组参数和变量名对应起来4、提取JSON数据：就是对象解构5、指定函数参数默认值6、遍历Map结构：配合变量的解构赋值，获取键名和键值就非常方便1234567891011121314const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 7、指定输入模块的具体方法：加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;); 【持续更新中…】注：大部分摘自阮一峰ES6入门，对此作高度总结分类，便于记忆]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【ES6】let、const]]></title>
      <url>%2F2018%2F%E3%80%90ES6%E3%80%91let%E3%80%81const.html</url>
      <content type="text"><![CDATA[[TOC] 块级作用域 let let作用域：大括号块中、函数内部 let声明不会被提升，所以会出现临时死区(TDZ) 如果作用域中存在的某个标识符再次使用let关键字声明就会报错 let在for这类的循环中，每次迭代都会创建一个新的变量，并以之前的同变量名值初始化 const 每个通过const声明的变量必须进行初始化 const与let都是块级标识符，只在当前代码块内有效 const也不会被提升 const常量名不能与var、let变量名重名 const声明对象不允许修改绑定，可以修改绑定的对象的属性值，如： const Person={name:”ww”}; Person.name=”aaa”; const在for-in for-of循环中使用行为与let一样，都会每次创建一个新的绑定 ES6中，默认使用const，确实需要改变的变量使用let ES6中let、const、class声明的全局变量不属于window对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈原生ajax]]></title>
      <url>%2F2018%2F%E6%B5%85%E8%B0%88%E5%8E%9F%E7%94%9Fajax.html</url>
      <content type="text"><![CDATA[[TOC] ajax主要解决了异步操作，通俗一点来讲就是在不刷新的页面的前提下，更新页面的数据。 ajax的核心就是XMLHttpRequest（xhr）。 使用原生ajax主要分为4个步骤：1.创建对象1var xhr=new XMLHttpRequest() 2.打开请求；1open(method，url，async) ①method是发送请求的方式一般常用的有get，post 关于post和get区别： (1)Get使用URL传参。而POST将数据放在BODY中。 (2)GET的URL会有长度上的限制（浏览器本身支持？服务器加限制截掉url），则POST的数据则可以非常大。 (3)POST比GET安全，因为数据在地址栏上不可见。②url请求的地址。③async是否异步取值有true/false.一般取值true;使用举例xhr.open(“get”,”exmple.txt”,true) 3.发送请求；1xhr.send(请求主体或null); 4.接受响应；1）可以通过检查xhr.readyState的值，来判断对应的请求处于什么状态•0: 未初始化。尚未调用open()方法•1: 启动。已经调用open()方法，尚未调用send()方法•2: 发送。已经调用send()方法，尚未收到响应。•3: 接收。已经接收到部分数据。•4: 完成。已经接收到全部响应数据。•当readystate值从一个值变为另一个值时，都会触发readystatechange事件。我们可以通过绑定onreadystatechange事件，来监听readystate的值是否为4 2）查看xhr.status值，查看服务器的响应结果•0 本地请求，服务器成功返回了页面•200 OK 服务器成功返回了数据或者页面•400Bad Request 语法错误导致服务器不识别•401Unauthorized 请求需要用户认证•404 Not found 指定的URL在服务器上找不到•500Internal Server Error 服务器遇到意外错误，无法完成请求•503ServiceUnavailable 由于服务器过载或维护导致无法完成请求3）如果1、2返回结果成功，则可以通过xhr的responseText，获得响应的内容 完整过程举例：123456789101112131415161718192021222324252627//1、创建一个XMLHttpRequest对象if(window.XMLHttpRequest)&#123; let xhr = new XMLHTTPRequest();&#125;else&#123; let xhr = new ActiveXObject();&#125;//2、打开请求，组装参数xhr.open(&apos;post&apos; , &apos;http://baodi.com&apos;,true);xhr.setRequestHeader(&apos;Content-Type&apos; , &apos;application/x-www-form-urlencoded&apos;);let form=document.getElementById(&apos;test-form&apos;);//3、发送请求xhr.send(new FormData(form));//4、监听响应xhr.onreadysstatechange=function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status == 304)&#123; //返回成功的处理 alert(xhr.responseText); &#125;else&#123; //返回失败的处理 xhr.status; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS正则表达式]]></title>
      <url>%2F2018%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      <content type="text"><![CDATA[[TOC] 正则符号1.字母与数字 .：查找单个字符，除了换行和行结束符 [a-z0-9]：方括号中任意字符 [0-9]：数字 \w： 查找单词字符 \d：数字 2.空白符 \b：匹配单词边界 var str=&quot;Visit Runooob&quot;; var patt1=/\bRun/g; \s：空白字符，包括空格、回车、换行、换页… \n：换行 \r：回车 3.定位符 ^：行首匹配，以什么开始的 ^(abc) $：行尾匹配，以什么结束的 ( def)$ 4.限定符 x?：匹配0个或1个 x*：匹配&gt;=0个 x+：匹配&gt;0个 x{m,n}：匹配m到n范围个 5.分组 (?:x)：匹配x但是不记录匹配结果 x(?=y)：x后紧跟着y时匹配x x(?!y)：当x后不是y时匹配x 正则常用方法字符串中方法 match:str.match(reg) 功能：match() 方法将检索字符串 str，以找到一个或多个与 reg匹配的文本 参数：reg正则表达式，如果表达式内没有g则只指向一次匹配 返回：如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息如果reg内不包含g则数组第 0 个元素包含匹配到的文本其余元素放的是分组匹配到的，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串；如果有 g 标识，则返回一个数组，包含每一次的匹配结果12345678var str = &apos;hello world&apos;; //首先创建好字符串var pattern = /([a-z]+)\s([a-z]+)/; //先通过正则匹配这个字符串，用分组模式来获取这两个单词var arr = str.match(pattern); // exec方法返回的是一个数组，包含匹配到的字符串以及分组(也称子串)里的值console.log(arr); //[&apos;hello world&apos;,&apos;hello&apos;,&apos;world&apos;] console.log(arr[0]); //&apos;hello world&apos; 匹配到的字符串console.log(arr[1]); //&apos;hello&apos; 第一个分组([a-z]+)的值console.log(arr[2]); //&apos;world&apos; 第二个分组([a-z]+)的值 2.replace 该方法不会改变原始字符串str.replace(要搜索的字段str/regexp,替换的新字段replacement)str.replace(reg,function(a){return }) replace 方法第二个参数替换的新字段replacement里面可以用 $1 - $9 来指代相应的分组 功能：找到要搜索的字串并逐一做处理替换，把匹配到的东西用return的东西替换 参数：要搜索的字段str/regexp,可以是字串和正则表达式。替换的新字段replacement，可以是字串和函数。 返回：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 3.searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 4.split接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中1234567891011121314var myString = &quot;Hello 1 word. Sentence number 2.&quot;; var splits = myString.split(/\d/); console.log(splits); // [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ] splits = myString.split(/(\d)/); console.log(splits); // [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]作者：网易考拉前端团队链接：https://juejin.im/post/59b5e50f51882519777c4815来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 正则对象reg的方法 test接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false 123var str = &quot;2017.06.27&quot;;var reg = /\b(\d+)\b/g;reg.test(str) exec同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本 小记javascript正则表达式里分组模式以小括号来()表示分组，例：/([a-z])/捕获性分组：()捕获性分组工作模式()会把每个分组里匹配的值保存起来。比如利用捕获性分组把 hello world 互换成 world hello：方法一：通过exec函数123456789101112var str = &apos;hello world&apos;; //首先创建好字符串var pattern = /([a-z]+)\s([a-z]+)/; //先通过正则匹配这个字符串，用分组模式来获取这两个单词var arr = pattern.exec(str); // exec方法返回的是一个数组，包含匹配到的字符串以及分组(也称子串)里的值console.log(arr); //[&apos;hello world&apos;,&apos;hello&apos;,&apos;world&apos;] console.log(arr[0]); //&apos;hello world&apos; 匹配到的字符串console.log(arr[1]); //&apos;hello&apos; 第一个分组([a-z]+)的值console.log(arr[2]); //&apos;world&apos; 第二个分组([a-z]+)的值//这时候两个分组的值都得到了,接下来用字符串拼接法实现互换var n_str = arr[2]+&apos; &apos;+arr[1];console.log(n_str) //world hello 方法二：通过属性$1-9123456789var str = &apos;hello world&apos;; var pattern = /([a-z]+)\s([a-z]+)/; pattern.test(str); //这个地方必须运行正则匹配一次，方式不限，可以是test()、exec()、以及String的正则方式console.log(RegExp.$1) //&apos;hello&apos; 第一个分组([a-z]+)的值console.log(RegExp.$2) //&apos;world&apos; 第二个分组([a-z]+)的值var n_str = RegExp.$2+&apos; &apos;+RegExp.$1;console.log(n_str) //world hello 方法三：通过String的replace()123456789101112131415161718192021var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot;作者：网易考拉前端团队链接：https://juejin.im/post/59b5e50f51882519777c4815来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于HTTP的小结]]></title>
      <url>%2F2018%2F%E5%85%B3%E4%BA%8EHTTP%E7%9A%84%E5%B0%8F%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC]HTTP是应用层协议，TCP是传输层协议Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。 HTTP报文组成 响应的格式大体也差不多 请求的起始行：请求类型 + URL + HTTP协议版本 响应的起始行：HTTP协议版本 + 状态码 + 原因短语 HTTP请求：1234567891011121314GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 //起始行Host: www.w3.org //首部开始Connection: keep-aliveCache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36Referer: https://www.google.com.hk/Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: authorstyle=yesIf-None-Match: &quot;2cc8-3e3073913b100&quot;If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT //首部结束name=qiu&amp;age=25 //主体 HTTP响应：12345678910111213HTTP/1.1 200 OKDate: Tue, 08 Jul 2014 05:28:43 GMTServer: Apache/2Last-Modified: Wed, 01 Sep 2004 13:24:52 GMTETag: &quot;40d7-3e3073913b100&quot;Accept-Ranges: bytesContent-Length: 16599Cache-Control: max-age=21600Expires: Tue, 08 Jul 2014 11:28:43 GMTP3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;Content-Type: text/html; charset=iso-8859-1&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125; 请求类型GET和HEAD方法被认为是安全的，安全的方法并不是什么动作都不执行，所谓的安全方法就是在使用可能引发不安全行为时允许HTTP应用程序开发者通知用户。 GETHTTP1.1要求服务器实现此方法。 HEAD只返回首部，不返回主体可以用于查看某个对象是否存在，或者测试资源是否被修改 PUT向服务器写入文档，很多都要求在执行PUT之前用密码登陆 TRACE 环回诊断行程最后一站服务器会弹回一条TRACE响应，并在响应主体中携带它原始报文请求 OPTIONS询问服务器支持哪些方法 DELETE请服务器删除请求URL所指定的资源 状态码1XX 100 continue ：收到请求的初始部分，请客户端继续。一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX 200 OK ：正常返回信息，主体部分包含所请求的资源 201 Created：请求成功，并且服务器创建了新的资源（一般用于PUT写入请求） 202 Accept；服务器已接受请求，但尚未处理 204 No Content：响应中没有实体 3XX 301 Moved Permanetly：永久重定向，请求的网页已永久移动到新位置 302 Found：临时重定向 303 See Other：临时重定向，告知客户端应该用另一个URL来请求资源，新的URL位于响应报文的location首部 304 Not Modified：自从上次请求后，请求的资源未修改过 4XX 400 Bad Request：告知客户端它发送了一个服务器无法理解的请求 401 Unauthorized：请求未授权，要先获取资源的访问权，一般需要密码等 403 Foebidden：禁止访问，由于IP、读写权限等 404 Not Found：找不到所请求的URL资源 5XX 500 Internal Server Error：服务器端错误，可能是程序错误、服务器关闭、服务器太忙等 503 Service Unavailable： 服务器端暂时无法处理请求（可能是过载或维护）。 HTTP缺点1.通信使用明文，内容可能会被窃听，即使加密，密文也可以被看到并解密 尺寸 n2.不验证通信双方身份，可能遭遇伪装3.无法证明报文的完整性，可能遭遇篡改 http2.0http2 是完全兼容 http/1.x 的，在此基础上添加了 4 个主要新特性： 二进制分帧：http/1.x 是一个文本协议，而 http2 是一个彻彻底底的二进制协议 多路复用：在 http/1.x 情况下，每个 http 请求都会建立一个 TCP 连接，这就意味着每个请求都需要进行三次握手。并且浏览器会限制同一个域名下并发请求的个数。所以，在 http/1.x 的情况下，一个常见的优化手段是把静态资源分布到不同域名下，以此来突破浏览器并发数的限制。在 http2 的情况下，所有的请求都会共用一个 TCP 连接，客户端请求会分解成多个帧，这些帧会在服务器端重新组合得到完整的请求 头部压缩： 减少 http header 在每次请求中消耗的流量 服务端推送：服务端推送指的是服务端主动向客户端推送数据。比如请求一个网页的时候服务器会把css、js资源也同时发送过来 HTTPS参考：https://www.jianshu.com/p/ca7df01a9041https://www.cnblogs.com/zxj015/p/6530766.html 共享密钥加密：加密和解密同用一个密钥,加密公开，密钥传给客户端是个问题 公开密钥加密：发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 HTTPS 采用混合加密机制：使用公开密钥加密传递密钥，然后使用共享加密密钥方式传输报文。 数字证书：公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。 HTTPS通信过程：第一次握手：(1)客户端发送Client Hello协商加密组件，报文中携带客户端支持的SSL版本和加密组件(2)服务器回应Server Hello，在报文中携带服务器对客户端SSL版本及加密组件支持情况(3)服务器发送公开密钥证书(4)服务器发送Server Hello Done通知客户端初始SSL协商部分结束进行一次验证(5)SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。(6)接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。(7)客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。(8)服务器同样发送 Change Cipher Spec 报文。(9)服务器同样发送 Finished 报文。建立完成，发送HTTP请求最后由客户端断开连接。断开连接时，发送 close_notify 报文 HTTPS比HTTP慢2到10倍SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。1、和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。2、另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL加速器的功效，以分担负载。SSLSSL是对http通信方式进行加密。改动了协议本身，在TCP层和HTTP层之间硬加了一层SSL层，与内容加密的方式不同 TCP三次握手与四次挥手]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS定位]]></title>
      <url>%2F2018%2FCSS%E5%AE%9A%E4%BD%8D.html</url>
      <content type="text"><![CDATA[[TOC] 脱离文档流：是指元素不占据标准流的空间 脱离文档流和层级是不同的概念，有层级不一定脱离了文档流 static：正常文档流，是position的默认值 relative：相对于元素正常位置进行定位，并且原本所占据的空间仍会保留，有层级概念 absolute：脱离标准流，不占据空间，后面的元素会占据它的位置，相对于值不为static的第一个父元素进行定位，有层级的概念。元素的宽高会失效 fixed：相对于浏览器有效区域定位（如果设置了top、bottom、left、right），否则与absolute一样相对于非static父元素，被固定在了页面上，不会随着滚动而滚动，元素的宽高会失效 行内元素设置了浮动就会成为块级元素 staticstatic是position默认值，一般配合JS来用，来取消一个元素的定位 relative不会脱离标准流，但是它的层级比标准流高，如果通过偏移和其他标准流元素重合会覆盖标准流元素，如果没有设置背景的话底层的元素文字会透过来。可以使用z-index来改变relative元素的层级由于relative并未脱离标准流，所以relative的left、right、top、bottom都可能会引起溢出。父元素定位到哪，子元素也会跟随到哪 absoluteabsolute会在标准流之上，后面的元素会移动过来。z-index可以改变层级关系，如果将absolute元素 的z-index设置为小于0的，则absolute元素会被标准流盖住。如果两个元素同时设置为position:absolute，则后来者居上，越后面的层级越高，会覆盖住前面的 fixed脱离标准流，不占据空间，相对于浏览器有效区域定位（如果设置了top、bottom、left、right），否则与absolute一样相对于非static父元素fixed会遮挡其他元素，解决这个问题可以设置border-x，但是在IE7以下不支持border-x属性，可以加一个div，给这个div设置高度将元素撑出来fixed的百分比是参照视口来计算的，无论有没有父元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【推荐】JS中是否改变原数组的常用方法归纳]]></title>
      <url>%2F2018%2F%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3.html</url>
      <content type="text"><![CDATA[[TOC] 改变原数组的：shift：将第一个元素删除并且返回删除元素，空即为undefinedunshift：向数组开头添加元素，并返回新的长度pop：删除最后一个并返回删除的元素push：向数组末尾添加元素，并返回新的长度reverse：颠倒数组顺序sort：对数组排序splice:splice(start,length,item)删，增，替换数组元素，返回被删除数组，无删除则不返回 不改变原数组的：concat：连接多个数组，返回新的数组join：将数组中所有元素以参数作为分隔符放入一个字符slice：slice(start,end)，返回选定元素map,filter,forEach,some,every等不改变原数组 不改变原字符串的str.replace()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS内存泄漏]]></title>
      <url>%2F2018%2FJS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html</url>
      <content type="text"><![CDATA[[TOC]内存泄漏：用完的内存没有被释放回收 造成泄漏的因素1.全局变量引起的内存泄漏：123function leaks()&#123; leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收&#125; 2.闭包引起的内存泄漏123456var leaks = (function()&#123; var leak = 'xxxxxx';// 被闭包所引用，不会被回收 return function()&#123; console.log(leak); &#125;&#125;)() 3.DOM删除时，事件未清除导致内存泄漏123$('#container').bind('click', function()&#123; console.log('click');&#125;).remove(); 4.循环引用5.setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS的弱类型]]></title>
      <url>%2F2018%2FJS%E7%9A%84%E5%BC%B1%E7%B1%BB%E5%9E%8B.html</url>
      <content type="text"><![CDATA[[TOC]所谓的弱类型是指不同类型之间可以直接隐士转换，JS中变量声明统一用var，会自动根据值转换成响应数据类型 JS中类型转换规则(1)一个操作数+一个字符串 会将操作数转化为字符串再相加： 3+”21” //结果是321(2)在+一元操作符会将操作数转换成number. 就如：1 + (+”2”) + “2” 结果是32(3)字母都无法转换成数字 Number(“A”)结果是NaN. “A”-“B”结果是NaN，进行算术运算时会自动转换成number进行运算(4)”-“作用都是”相减”，非数字类型的会转化成数字类型(5)NaN同任何数字进行加减乘除等操作都是NaN，比较都是false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源与跨域]]></title>
      <url>%2F2018%2F%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F.html</url>
      <content type="text"><![CDATA[[TOC] URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说浏览器禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 浏览器中有哪些不受同源限制呢？&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;这些包含 src 属性的标签可以加载跨域资源。但浏览器限制了JavaScript的权限使其不能读、写加载的内容。 跨域技术：CORS、图像Ping、jsonp、iframe、comet、服务器发送事件、web sockets CORS跨域资源共享(cross-irigin resourses sharing)跨域资源共享（CORS）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。在请求中附加一个额外的origin头部，其中包含请求页面的源信息(协议、域名、端口号) 图像ping 概念：利用&lt;img&gt;标签没有域的限制特性，在img的src中传递参数。 图像ping是单向的跨域通信方式，浏览器只能得到一个响应状态，得不到任何参数、数据，通过监听img的load事件和error事件，判断什么时候收到响应 123456var img=new Image();img.src="http://baidu.com/test?name=wang";img.onload=img.onerror=function()&#123; alert("收到");&#125; jsonp jsonp利用script标签没有域的限制特性，在script是src中添加参数，与图像ping类似，但是它有返回的数据、回调函数。 jsonp请求由两部分组成：参数+回调函数名。http://baidu.com/test?参数1=参数1的值&amp;callback=回调函数名 jsonp返回由两部分组成；回调函数+数据 请求端：1234567891011 var script = document.createElement('script');script.type = 'text/javascript';// 传参并指定回调执行函数为onBackscript.src = 'http://www.....:8080/login?user=admin&amp;callback=onBack';document.head.appendChild(script);// 回调函数function onBack(res) &#123;//res是返回的数据 alert(JSON.stringify(res));&#125; iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。使用document.getElementById(&#39;iframe的id&#39;).contentWindow获取iframe中的window对象使用window.parent.父页面中变量可以获取父页面中变量s12345678910111213141516 此方案仅限主域相同，子域不同的跨域应用场景。 1.父窗口：(http://www.domain.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;; &lt;/script&gt; 2.子窗口：(http://child.domain.com/b.html) &lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web攻击方法及防御]]></title>
      <url>%2F2018%2Fweb%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E5%8F%8A%E9%98%B2%E5%BE%A1.html</url>
      <content type="text"><![CDATA[[TOC] CSRF、XSS、session攻击 CSRF跨站请求伪造攻击（cross-site request forgery）1.概念：用户浏览器同时打开正常网站和钓鱼网站时，钓鱼网站利用图片隐藏链接或者JS脚本操纵用户发送请求给正常的网站，因为此时用户是通过了session验证的，所以钓鱼网站的请求会得以执行。2.这个攻击方法就是利用用户已登陆的正常网站的session等一些已有验证，偷偷在用户浏览器上执行恶意请求。 下面有个很形象的图表示： 3.CSRF类型： GET类型的CSRF：&lt;img src=http://wooyun.org/csrf?xx=11 /&gt; 在访问含有这个img的页面后，偷偷向http://wooyun.org/csrf?xx=11 发出了一次HTTP请求 POST类型的CSRF：偷偷发起post请求 1234&lt;form action=http://wooyun.org/csrf.php method=POST&gt;&lt;input type=&quot;text&quot; name=&quot;xx&quot; value=&quot;11&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 其他其他猥琐流CSRF： 根本原因：web的隐式身份验证机制解决办法：1.验证HTTP Referer字段:Referer字段记录了HTTP请求的来源地，可以判别是否是钓鱼网站发起的请求2.在请求地址中添加token：在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求3.在HTTP头中自定义属性并验证：这种方法也是使用 token 并进行验证，但是是把token放在HTTP头中自定义token，通过SMLHTTPRequest（ajax）类添加 XSS跨站脚本攻击(cross site script)1.概念：网站对攻击者提交的一些数据没有转义或过滤，导致一些恶意代码添加到网页中（比如评论区中），其他用户浏览网页的时候，这些携带的代码得以执行。 例如在一个论坛评论中发表：1&lt;script&gt;alert(&apos;hacked&apos;)&lt;/script&gt; 这样的话，当其他用户浏览到这个页面，这段js代码就会被执行。当然，我们还可以执行一些更严重的代码来盗取用户信息。分类： 非持久性XSS：一次性执行的，服务器仅将XSS代码保存在内存中，每次触发XSS都需要由用户输入相关的XSS代码 持久性XSS：XSS代码保存在数据库中，XSS代码只需一次输入 DOM XSS：完全在前端浏览器触发，无需服务端，预防DOM XSS，需要前端开发人员警惕用户所有的输入数据，做到数据的excape转义，同时尽可能少的直接输出HTML的内容；不用eval、new Function、setTimeout等较为hack的方式解析外站数据和执行js脚本；禁止内联事件处理函数；如果在考虑安全性的前提下需要获取外站脚本的执行结果，可以采用前端沙盒。 解决办法： 转移和过滤用户提交的信息 session攻击，会话劫持1.概念：用某种手段得到用户session ID后，冒充用户进行请求2.session ID一般是以cookie形式存储在用户本地，session的value是存储在服务器上的，用户通过session ID可以请求服务器获得session的value 原因： 由于http本身无状态，为了维持会话，会设置一个session ID用来认证用户，基于这个标识进行用户授权，只有请求中带有这个标识才能得到响应 三种攻击者获取用户session ID的方式：1.预测：猜session ID，这种方法不靠谱，session ID很复杂的2.会话劫持： URL参数传递sessionID； 隐藏域传递sessionID；比较安全的是cookie传递。但同样也可以用xss攻击取得sessionID3.会话固定： 诱骗用户使用指定的sessionID进行登录，这样系统不会分配新的sessionID 防御方法：每次登陆重置sessionID设置HTTPOnly，防止客户端脚本访问cookie信息，阻止xss攻击关闭透明化sessionIDuser-agent头信息验证token校验 【持续更新…】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中百分比相对于谁]]></title>
      <url>%2F2018%2FCSS%E4%B8%AD%E7%99%BE%E5%88%86%E6%AF%94%E7%9B%B8%E5%AF%B9%E4%BA%8E%E8%B0%81.html</url>
      <content type="text"><![CDATA[[TOC] 相对于父元素宽度的：[max/min-]width、left、right、text-indent、padding、margin 等； 相对于父元素高度的：[max/min-]height、top、bottom 等； 相对于主轴长度的：flex-basis 等； 相对于继承字号的：font-size 等； 相对于自身字号的：line-height 等； 相对于自身宽高的：border-radius、background-size、border-image-width、transform: translate()、transform-origin、zoom、clip-path 等； 相对于行高的：vertical-align 等； 特殊算法的：background-position （方向长度 / 该方向除背景图之外部分总长度）、border-image-slice （相对于图片尺寸）、filter 系列函数等；破坏文档流的div高度设为百分比是相对谁而言的 如果自身设置 position: absolute的div中宽、高百分比是相对于离它最近的那个 position 不为 static 的祖先元素，如果没有这样的元素，则相对于视口。 如果 position: fixed：百分比是相对于视口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重绘与回流]]></title>
      <url>%2F2018%2F%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81.html</url>
      <content type="text"><![CDATA[[TOC] 回流（重排）：渲染树的一部分必须要更新且节点的尺寸发生了变化，会触发重排操作。每个页面至少在初始化的时候会有一次重排操作 重绘：部分节点需要更新，但没有改变其形状，会触发重绘操作。比如背景颜色的变化 会触发重绘或回流/重排的操作1、添加、删除元素(回流+重绘)2、隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)3、移动元素，如改变top、left或移动元素到另外1个父元素中(重绘+回流)4、改变浏览器大小(回流+重绘)5、改变浏览器的字体大小(回流+重绘)6、改变元素的padding、border、margin(回流+重绘)7、改变浏览器的字体颜色（只重绘，不回流）8、改变元素的背景颜色（只重绘，不回流）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中可以和不可以继承的属性]]></title>
      <url>%2F2018%2FCSS%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7.html</url>
      <content type="text"><![CDATA[[TOC] 无继承性的属性1、display：规定元素应该生成的框的类型2、文本属性：vertical-align：垂直文本对齐text-decoration：规定添加到文本的装饰text-shadow：文本阴影效果white-space：空白符的处理unicode-bidi：设置文本的方向3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index6、生成内容属性：content、counter-reset、counter-increment7、轮廓样式属性：outline-style、outline-width、outline-color、outline8、页面样式属性：size、page-break-before、page-break-after9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 有继承性的属性1、字体系列属性font：组合字体font-family：规定元素的字体系列font-weight：设置字体的粗细font-size：设置字体的尺寸font-style：定义字体的风格font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。2、文本系列属性text-indent：文本缩进text-align：文本水平对齐line-height：行高word-spacing：增加或减少单词间的空白（即字间隔）letter-spacing：增加或减少字符间的空白（字符间距）text-transform：控制文本大小写direction：规定文本的书写方向color：文本颜色3、元素可见性：visibility4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style6、生成内容属性：quotes7、光标属性：cursor8、页面样式属性：page、page-break-inside、windows、orphans9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation 所有元素可以继承的属性1、元素可见性：visibility2、光标属性：cursor 内联元素可以继承的属性1、字体系列属性2、除text-indent、text-align之外的文本系列属性 块级元素可以继承的属性1、text-indent、text-align]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BFC块格式化上下文]]></title>
      <url>%2F2018%2FBFC%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87.html</url>
      <content type="text"><![CDATA[[TOC] BFC：block formatting contextBFC的理解则是：元素所处的环境以及初始化就叫格式化上下文。格式化就是初始化，上下文是环境。它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。 也就是说，如果一个元素符合了成为BFC的条件，该元素内部元素的布局和定位就和外部元素互不影响(除非内部的盒子建立了新的 BFC)，是一个隔离了的独立容器 根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当开启元素的BFC以后，元素将会具有如下的特性：1.当两个元素属于不同的 BFC 时，外边距不会合并2.同一个BFC内父子、兄弟元素的垂直外边距会发生合并2.开启BFC的元素不会被浮动元素所覆盖3.开启BFC的元素可以包含浮动的子元素4.BFC的区域不会与float box重叠，就是说BFC不会占据float的空间 BFC作用：1.包含浮动元素，BFC容器可以包含浮动元素，解决高度塌陷，将父元素设置为:overflow:hidden2.不被浮动元素覆盖，设置BFC的元素不会与占据浮动元素空间3.阻止外边距合并，两个BFC外边距不会合并4.清除浮动; 开启元素BFC1.设置元素浮动flaot-使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失-而且使用这种方式也会导致下边的元素上移，不能解决问题2.设置元素绝对定位position:absolute或fixed3.设置元素display 为以下其中之一的值 inline-blocks，table-cells(表格单元格)，table-captions(表格标题)、flow-root inline-blocks可以解决问题，但是会导致宽度丢失，不推荐使用这种方式4.将元素的overflow设置为一个非visible的值-推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。注意：在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：直接将元素的zoom设置为1即可zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍zoom:1表示不放大元素，但是通过该样式可以开启hasLayoutzoom这个样式，只在IE中支持，其他浏览器都不支持 那么BFC又有以下特性： 内部块级盒子垂直方向排列 BFC就是一个隔离的容器，内部子元素不会影响到外部元素 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 注：IFC是行内格式化上下文，是计算行高的一些东西]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[click和onclick本质的区别]]></title>
      <url>%2F2018%2Fclick%E5%92%8Conclick%E6%9C%AC%E8%B4%A8%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[[TOC]cilck是方法，不会自动触发，onclick是事件，达到条件会自动触发 click可以模拟点击事件 onclick是一个事件1.事件名前一般都以on开头；2.方法是程序员写语句直接调用，即显示调用；【可以触发onclick事件】 3.事件不需程序员调用，但是，必须由程序员写一个函数且将该函数赋值给相应的事件，其调用是在相应的事件触发时。【告诉浏览器在鼠标点击时候要做什么】所以调用顺序是：首先方法其次事件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的异步以及事件轮询机制]]></title>
      <url>%2F2018%2FJS%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6.html</url>
      <content type="text"><![CDATA[[TOC] JS单线程与浏览器多线程JS是单线程的，但是浏览器内核是多线程的HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM 浏览器多线程： JS引擎线程（JS引擎有多个线程，但是只有一个主线程，其他后台配合主线程） UI渲染线程：与JS引擎线程互斥 浏览器事件触发线程 http请求线程：ajax等 定时器触发线程 事件轮询处理线程：轮询任务队列 异步异步是浏览器的两个或者两个以上线程共同完成的。比如ajax异步请求和setTimeoutJS的异步是通过回调函数实现的，即通过任务队列，在主线程执行完当前的任务栈（所有的同步操作），主线程空闲后轮询任务队列，并将任务队列中的任务（回调函数）取出来执行。虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。 123 1. onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中。2. setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。3.ajax 则会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。 JS异步运行机制：1234（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法的时间复杂度计算]]></title>
      <url>%2F2018%2F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97.html</url>
      <content type="text"><![CDATA[[TOC]时间复杂度是总运算次数表达式中受n的变化影响最大的那一项(不含系数) 步骤1.找出算法中执行次数最多的那条语句，通常是内层循环体2.计算基本语句的执行次数的数量级，可以忽略所有低次幂和最高次幂的系数3.用大Ο记号表示算法的时间性能4.如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加 规则1.嵌套循环：循环次数相乘2.并列循环：循环次数相加，其实就是循环次数最大的那个3.大O表示法中相加项取最高次幂那项：O(N+N^2)=O(n^2)4.O(1)表示基本语句执行次数是一个常数，算法中不存在循环语句5.大O只考虑阶数，系数和常数去掉：O(1+n(n+1)/2)=O(n^2)6.时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。 例子1.for123int i,j; for(i=0;i&lt;n;i++) for(j=i;j&lt;n;j++); 执行次数是n+(n-1)+(n-2)+…+1，所以复杂度是O(n^2) 2.log(n)123int i=1;while(i&lt;n) i*=2; 每次执行i都乘以2，设执行次数是x，那么此时的i=1*2*2*2*...*2=2^x，跳出循环应该 2^x&gt;=n，所以执行次数x=log(n)，循环复杂度为O(log(n))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深拷贝与浅拷贝]]></title>
      <url>%2F2018%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.html</url>
      <content type="text"><![CDATA[[TOC] 首先深拷贝和浅拷贝只针对像 Object, Array 这样的复杂对象的。简单来说，浅拷贝只复制一层对象的属性，而深拷贝则递归复制了所有层级。 浅拷贝:快速浅拷贝数组方法：copy = array.slice();ES5中浅拷贝：mixin(destObj,sourseObj.prototype);ES6中新增:Object.assign(destObj,sourseObj.prototype);1234567891011var obj=&#123;a:1;arr:[2,3]&#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 复制的arr属性的值是个引用，改变它的值会引起原来的obj中该值也会变。 深拷贝：1234567891011121314var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123;//如果值不是对象，直接返回 return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS模块化编程]]></title>
      <url>%2F2018%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B.html</url>
      <content type="text"><![CDATA[[TOC] 模块的写法原始写法123456function m1()&#123; //... &#125; function m2()&#123; //... &#125; 这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 对象写法123456789var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125; &#125;); 这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。如：module1._count = 5; 立即执行函数写法12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 这样外部无法读取内部变量 放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。123456 var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod; &#125;)(module1); 宽放大模式（Loose augmentation）在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。1234 var module1 = ( function (mod)&#123; //... return mod; &#125;)(window.module1 || &#123;&#125;); 与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中map函数]]></title>
      <url>%2F2018%2FJS%E4%B8%ADmap%E5%87%BD%E6%95%B0.html</url>
      <content type="text"><![CDATA[[TOC]map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。 传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该有返回值。注意：map()返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。 举个例子： 要求：为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组 12345function square(arr)&#123; return arr.map(function(item)&#123; //数组会把没个元素依次传递给item参数，与foreach循环一样 return item*item; &#125;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6语法]]></title>
      <url>%2F2018%2FES6%E8%AF%AD%E6%B3%95.html</url>
      <content type="text"><![CDATA[[TOC] 块级作用域let let作用域：大括号块中、函数内部 let声明不会被提升，所以会出现临时死区(TDZ) 如果作用域中存在的某个标识符再次使用let关键字声明就会报错 let在for这类的循环中，每次迭代都会创建一个新的变量，并以之前的同变量名值初始化 const 每个通过const声明的变量必须进行初始化 const与let都是块级标识符，只在当前代码块内有效 const也不会被提升 const常量名不能与var、let变量名重名 const声明对象不允许修改绑定，可以修改绑定的对象的属性值，如： const Person={name:”ww”}; Person.name=”aaa”; const在for-in for-of循环中使用行为与let一样，都会每次创建一个新的绑定 ES6中，默认使用const，确实需要改变的变量使用let 函数参数默认值 ES5中使用默认参数的方法是：name=name||mick; ES6中直接在函数接收参数里定义参数默认值:function Person(name,age=18) 只有当不为参数传入值或者主动为它传入undefined是才会使用默认值，传入null并不会使用默认值 参数的默认值可以通过调用函数来获得，函数不会在声明时调用，只有在传参时才会调用 函数参数后面的参数可以用前面的参数作为默认值，因为前面的先声明 默认值对arguments影响 ES5中： 非严格模式下，命名参数的变化会与arguments对象实时更新 严格模式下，arguments传入的是参数的静态副本，不会随参数变化而变化 ES6中，如果一个参数使用了默认值，无论是在严格还是非严格模式下，arguments对象都与命名参数分离 不定参数在函数命名参数前添加...表示这时一个补丁参数，该参数为一个数组，包含着自它之后传入的所有参数1234function Person(name,age,...others)&#123; for(let i=0;i&lt;others.length-1;i++)&#123; &#125;&#125; 每个函数最多只能定义一个不定参数，而且一定要放在末尾 块级函数 ES6可以在代码块中声明一个函数，称为块级函数 块级函数 在严格模式下：会将声明提升至代码块顶部 在非严格模式下：提升至外围函数或全局的顶部 箭头函数 目标是替代匿名函数，语法更简洁 this arguments super new.targets这些值由外围最近的一层非箭头函数决定 不能通过new调用 没有原型prototype 无论时严格还是非严格模式下，箭头函数都不支持重复声明命名函数 箭头函数形式： 1.一个参数：let test = param =&gt; returnValue; 2.多参数： let test=(param1,param2) =&gt; param1+param2; 3.无参： let test=() =&gt; returnValue; 4.多表达式函数体：let test = (param1,param2) =&gt;{return param1+param2;}; 5.空函数： let test = () =&gt; {}; 6.返回对象字面量： let test=id =&gt; ({id:id , name:”aaa”});//返回的对象字面量要用括号包起来 尾调用 是指函数作为另一个函数的最后一条执行语句被调用 尾调用优化：不建立新的栈帧，清除并重用当前的栈帧。减少内存的使用，避免栈溢出错误 满足下面两个个条件才可以被JavaScript引擎自动优化尾调用： 1.尾调用不访问当前栈帧的变量，不是闭包 2.函数返回结果直接作为返回值，没有其他运算 Promise异步romise是一种封装未来值的易于复用的异步任务管理机制,主要解决地狱回调和控制异步的顺序 Promise的三种状态 fulfilled：满足，成功 rejected：拒绝，失败 pending：初始状态注：settled是指fulfilled，rejected状态之一。 Promise()构造函数12345678910111213// resolver为 function(resolve, reject)&#123; ... &#125;function Promise(resolver)&#123; if(resolver &amp;&amp; typeof resolver !== 'function')&#123; throw new Error('Promise resolver is not a function') &#125; //当前promise对象的状态 this.state = PENDING; //当前promise对象的数据（成功或失败） this.data = UNDEFINED; //当前promise对象注册的回调队列 this.callbackQueue=[]; //执行resove()或reject()方法 if(resolver) executeResolver.call(this, resolver);&#125;Promise.prototype.then = function()&#123;&#125; 构造器初始化：123456new Promise(function(resolve, reject)&#123; resolve(value1);//异步调用成功的函数并传值 reject(value2);&#125; ).then(function(value1)&#123; //成功，接收value1&#125;,function(value2)&#123;//失败&#125;); 构造函数用于生成Promise对象，executor函数在Promise构造函数执行时同步执行。resolve，reject函数被调用时分别将Promise状态设置为fulfilled，rejected Promise实例方法：then( onfulfilled, onrejected ), catch( onrejected )then和catch用于处理Promise fullfilled成功或者rejected失败时候的情况。更加推荐的做法：myPromise.then(onfulfilled).catch(onrejected);这样的好处：1.then，catch区分开，分别处理成功，失败，代码更容易理解。2.then().then().then().catch(); then，catch方式可以捕获到前面多个then中的异常。 Promise可以链式调用的原因？因为Promise.prototype.then方法和Promise.prototype.catch方法都返回Promise对象。所以可以链式调用:1myPromise.then(xxx).then(xxx); 特点所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。Promise 对象有以下两个特点： (1)、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。(2)、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中类型判断]]></title>
      <url>%2F2018%2FJS%E4%B8%AD%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.html</url>
      <content type="text"><![CDATA[[TOC]typeofinstanceofhasOwnProperty typeoftypeof只能区分下面的类型：undefinedbooleannumberstringobject：对象、null、数组function：函数typeof不适合用于判断是否为数组。当使用typeof判断数组和对象的时候，都会返回object。可以使用isArray()来判断是否为数组。 NaN（就是not a number啦）和infinity一样是number类型的一个特殊的值 typeof null===”object” instanceofinstanceof 用于判断一个变量是否某个对象的实例。instance只能用来判断对象和函数，不能用来判断字符串、数组等 constructor返回对创建此对象的原始封装类对象。原始封装对象有：Object、Array、Boolean、Number、String、Function、Date、Math、RegExp、Arguments如：str.constructor是String、array.constructor是Array prototype（推荐）Object.prototype.toString.call(对象)来判断对象类型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[json字符串、json对象、json数组的区别]]></title>
      <url>%2F2018%2Fjson%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81json%E5%AF%B9%E8%B1%A1%E3%80%81json%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[[TOC] JSON对象先介绍一下json对象，首先说到对象的概念，对象的属性是可以用：对象.属性进行调用的。例如：123var person=&#123;"name":"tom","sex":"男","age":"24"&#125;//json对象 console.log(person.name);//在控制台输出tom alert(typeof(person));//object JSON字符串字符串，我们常说的javascript中的字符串是单引号或者双引号引起来的。那么json字符串是什么概念呢？1var b='&#123;"name":"2323","sex":"afasdf","age":"6262"&#125;';//json字符串 json数组数组可包含多个对象，1234567&#123; "employees": [ &#123; "firstName":"John" , "lastName":"Doe" &#125;, &#123; "firstName":"Anna" , "lastName":"Smith" &#125;, &#123; "firstName":"Peter" , "lastName":"Jones" &#125; ] &#125; json字符串和json对象的转换 字符串—-&gt;对象 ：parse(jsonString) 对象—-&gt;字符串 ：JSON.stringify(jsonObj)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS继承的几种方法]]></title>
      <url>%2F2018%2FJS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
      <content type="text"><![CDATA[[TOC] JS实现继承有四种方式：1.原型链继承2.构造继承3.组合继承4.实例继承5.拷贝继承 原型链继承1Child.prototype=new Parent()； 原型链继承是儿子的原型是父亲的一个实例，这样儿子就能继承Parent 缺点：子类的所有实例都共享着原型上的所有属性和方法。通过子类实例，可以访问原型上的属性，但是，不能重写原型上的属性。原型上引用类型的值可以通过实例进行修改，而且所有的实例访问到的该引用类型的值也会随之改变。* 构造继承123456789101112function Person(name,age)&#123; this.name=name; this.age=age; this.eat=function()&#123;alert("吃饭");&#125;&#125;function stu(stuId,name,age)&#123; this.stuId=SstuId; Person.call(this,name,age);&#125;var cat = new stu(1,"wabf",22); 优点：1.解决了原型链方式中子类实例共享父类引用属性的问题2.创建子类实例时，可以向父类传递参数3.可以实现多继承（call多个父类对象） 缺点：1.实例并不是父类的实例，只是子类的实例2.智能继承父类的实例属性和方法，不能继承父类原型属性和方法3.无法实现函数复用，每个子类都有父类实例属性副本 组合继承将原型继承和构造继承组合在一块，发挥二者之长组合继承也是需要修复构造函数指向的12345678910111213141516function Person(name)&#123; this.name=name;&#125;Person.prototype.sayName=function()&#123; console.log(this.name);&#125;function Child(name,age)&#123; Parent.call(this,name); this.age=age;&#125;Child.prototype=new Person();Child.pprototype.constructor=Child;//组合继承也是需要修复构造函数指向的child1=new Child("mick",22); 特点：弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例不存在引用属性共享问题可传参函数可复用 缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 实例继承在子类构造函数中new父类，并为父类添加新属性，然后构造函数返回这个new的实例。123456function Cat(name)&#123; var instance=new Animal(); instance.name=name || 'Tom'; return instance;&#125;var cat1=new Cat(); 拷贝继承在子类中new一个父类实例，然后遍历父类实例属性复制到子类的prototype上123456789function Cat(name)&#123; var instance=new Animal(); for(var p in instance)&#123; Cat.prototype[p]=instance[p]; &#125; Cat.prototype.name=name||"Tom";&#125;var cat1=new Cat();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apply()、call()、bind()的区别]]></title>
      <url>%2F2018%2Fapply()%E3%80%81call()%E3%80%81bind()%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[[TOC]都用于改变函数的执行环境，可以改变函数体内 this 的指向1.JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：12345/*apply()方法*/function.apply(thisObj[, 参数数组])/*call()方法*/function.call(thisObj,arg1,arg2...); 它们各自的定义：apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 bind()方法 概念：bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数 bind与apply、call最大的区别就是：bind不会立即调用，其他两个会立即调用 例子:12345678910111213var cat = &#123;color:"blue"&#125;; window.color = "red"; function showColor()&#123; console.log(this.color); &#125; showColor.bind(cat); //没有任何输出 showColor.bind(cat)(); //输出blue showColor.call(cat);//输出blue showColor.apply(cat);//输出blue var newShowColor = showColor.bind(cat); newShowColor(); //输出blue]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS写排序算法]]></title>
      <url>%2F2018%2FJS%E5%86%99%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
      <content type="text"><![CDATA[[TOC] 排序算法冒泡排序从一端开始将相邻的两个比较，大的往后移动，这样一轮比下来，最大数冒泡到最后了，对剩下的序类按此交换 选择排序和冒泡排序类似，都是一轮排序后把最大的数放到最后。不同的是冒泡是没相邻两个比较，选择排序首先要遍历该数组，把最小的数字和第一个位置的数字交换，这样就把最小的数字放到了最左边。对剩下的序类也按次交换。 插入排序和打扑克牌一样的道理，拿到一张牌找到一个合适的位置插入。如序类5,3,8,6,4。第一张牌作为基准，然后第二张牌3要插入到5后面，那么就把从5开始后移一位，放入3，变成了3，5，8，6，4.然后拿到第三章牌8，它比前面排序好的数都大，不动。拿到第四张牌6的时候把它插到8前面。1234567891011function insertSort(arr)&#123; var temp; //temp变量用于临时存储待插入元素 for(var i=1; i&lt;arr.length; i++)&#123; temp = arr[i]; //从前往后查找插入位置 for(var j=i; j&gt;0&amp;&amp;arr[j-1]&gt;temp; j--)&#123; arr[j]=arr[j-1]; //将大于temp的arr[j]元素后移 &#125; arr[j]=temp; &#125;&#125; 快速排序选择一个基准，序类中每个数都和这个基准比较，小的放在left数组，大的放在right数组。然后分别对基准左右两边的子序类进行相似的比较，依次递归。1234567891011121314151617var quickSort=function(arr)&#123;if(arr.length&lt;=1)&#123; return arr;&#125;var left=[];var right=[];var index=Math.floor(arr.length/2);indexValue=arr.splice(index,1)[0];for(var i=0;i&lt;arrNew.length-1;i++)&#123; if(arrNew[i]&gt;arr[index])&#123; left.push(arrNew[i]); &#125;else&#123; right.push(arrNew[i]); &#125;&#125;return quickSort(left).concat([indexValue],quickSort(right));&#125;; 常规的快排：https://blog.csdn.net/morewindows/article/details/6684558对挖坑填数进行总结1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。一次快排下来，最初选择的基数两边分别是比它小和大的1234567891011121314151617181920212223242526272829303132333435363738394041/* 挖坑填数,即一次快排 1.i=L;j=R;基准数选择X=arr[i]挖一个坑 2.j-- 从后往前找到比X小的数填到坑arr[i]中，此时多出了一个坑arr[j] 3.i++ 从前往后找到比X大的一个数填到arr[j]坑中 4.重复2，3步骤知道i==j，将X基准数填入arr[i]中,返回此时基准数所在的位置index*/function ajustArray(arr,l,r)&#123; var X=arr[l]; var i=l,j=r; while(i&lt;j)&#123; //从后往前找比基数X小数，填到坑i处，且产生坑j while(i&lt;j &amp;&amp; arr[j]&gt;=X)&#123; j--; &#125; if(i&lt;j)&#123; arr[i]=arr[j]; i++; &#125; //从前往后找比X大的数，填到坑j处 while(i&lt;j &amp;&amp; arr[i]&lt;X)&#123; i--; &#125; if(i&lt;j)&#123; arr[j]=arr[i]; j--; &#125; &#125; //此时i==j，将X基准数填入arr[i]中，返回此时基准数所在的位置index arr[i]=X; return i;&#125; function quickSort(arr,l,r)&#123; if(l&lt;r)&#123; var index=ajustArray(arr,l,r);//一次快排 quickSort(arr,l,index-1);//左边递归 quickSort(arr,index+1,r);//右边递归 &#125;&#125; 判断两个链表是否相交并找出交点如果两个链表相交那么尾部一定相等，假设第一个链表长度时L1，第二个长L2，交点不可能在长的L2-L1这段差值之间，所以先让较长的L2走完L2-L1这一段，然后两个链表同时走，判断什么时候相等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git命令]]></title>
      <url>%2F2017%2Fgit%E5%91%BD%E4%BB%A4.html</url>
      <content type="text"><![CDATA[设置用户信息git config –global user.name “wanghansong”git config –global user.email 614158750@qq.com 生成ssh公钥ssh-keygen -t rsa -C 614158750@qq.com然后回车，期间会问你生成的文件名和passphrase，对于我这种菜鸟，我一路点回车。如果你也是菜鸟，跟我一样做。 （passphrase 可以设置密码）上一步生成的文件放在了C:/Users/用户名（你的windows用户）/.ssh/文件夹中，用记事本打开其中的id_rsa.pub文件，全部内容复制。登录github网站，找到account setting,将刚才复制的粘贴到key文本框中。 同步1.（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库git init 2.把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件git add . 3.用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明git commit -m ‘first commit’ 4.关联到远程库git remote add origin 你的远程库地址如：git remote add origin https://github.com/cade8800/ionic-demo.git 5.获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）git pull –rebase origin master //注意是两个横线 6.把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。git push -u origin master 7.状态查询命令git status]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js 20行贪吃蛇代码]]></title>
      <url>%2F2017%2Fjs%2020%E8%A1%8C%E8%B4%AA%E5%90%83%E8%9B%87%E4%BB%A3%E7%A0%81.html</url>
      <content type="text"><![CDATA[[TOC] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;贪吃蛇重构&lt;/title&gt; &lt;style&gt; body &#123; display: flex; height: 100vh; margin: 0; padding: 0; justify-content: center; align-items: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="can" width="400" height="400" style="background-color: black"&gt;对不起，您的浏览器不支持canvas&lt;/canvas&gt; &lt;script&gt; var snake = [41, 40], //snake队列表示蛇身，初始节点存在但不显示 direction = 1, //1表示向右，-1表示向左，20表示向下，-20表示向上 food = 43, //食物的位置 n, //与下次移动的位置有关 box = document.getElementById('can').getContext('2d'); //从0到399表示box里[0~19]*[0~19]的所有节点，每20px一个节点 function draw(seat, color) &#123; box.fillStyle = color; box.fillRect(seat % 20 *20 + 1, ~~(seat / 20) * 20 + 1, 18, 18); //用color填充一个矩形，以前两个参数为x，y坐标，后两个参数为宽和高。 &#125; document.onkeydown = function(evt) &#123; //当键盘上下左右键摁下的时候改变direction direction = snake[1] - snake[0] == (n = [-1, -20, 1, 20][(evt || event).keyCode - 37] || direction) ? direction : n; &#125;; !function() &#123; snake.unshift(n = snake[0] + direction); //此时的n为下次蛇头出现的位置，n进入队列 if(snake.indexOf(n, 1) &gt; 0 || n &lt; 0 || n &gt; 399 || direction == 1 &amp;&amp; n % 20 == 0 || direction == -1 &amp;&amp; n % 20 == 19) &#123; //if语句判断贪吃蛇是否撞到自己或者墙壁，碰到时返回，结束程序 return alert("GAME OVER!"); &#125; draw(n, "lime"); //画出蛇头下次出现的位置 if(n == food) &#123; //如果吃到食物时，产生一个蛇身以外的随机的点，不会去掉蛇尾 while (snake.indexOf(food = ~~(Math.random() * 400)) &gt; 0); draw(food, "yellow"); &#125; else &#123; //没有吃到食物时正常移动，蛇尾出队列 draw(snake.pop(),"black"); &#125; setTimeout(arguments.callee, 150); //每隔0.15秒执行函数一次，可以调节蛇的速度 &#125;(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html基础head]]></title>
      <url>%2F2017%2Fhtml%E5%9F%BA%E7%A1%80head.html</url>
      <content type="text"><![CDATA[[TOC] DOCTYPE告知浏览器文档使用哪种HTML或者XHTML html5中doctype不区分大小写 charset声明文档使用的字符编码html5中：&lt;meta charset=&quot;utf-8&quot;&gt;html5之前：&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot; charset=&quot;utf-8&quot;&gt; lang&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;使用zh-cmn-Hans比使用zh-CN兼容性更好，zh-CN带有地域性，无法匹配zh-SG（新加坡） 优先使用IE最新版和chrome1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 1&lt;meta name=“renderer” content=“webkit|ie-comp|ie-stand”&gt; content的取值为webkit，ie-comp，ie-stand之一，区分大小写，分别代表用极速模式，兼容模式，IE模式打开。 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，脱下你的衣服，往你的身上贴狗皮膏药的广告，为此可在 head 内添加 1&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt; SEO 关键词： 1&lt;meata name=&quot;keywords&quot; content=&quot;关键词...&quot;&gt; 页面描述description 1&lt;meta name=&quot;description&quot; content=&quot;描述...&quot;&gt; 定义网页作者author 1&lt;meta name=&quot;author&quot; content=&quot;王寒松&quot;&gt; 定义网页搜索引擎索引模式 1&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; 123456789follow 跟踪链接并分析目标网页。这是默认行为，并且可忽略。nofollow 属性指示搜索引擎将当前网页的内容编入索引，但忽略该网页上超链接的目标。noindex 属性指示搜索引擎忽略当前网页的内容，并继续将网站中的其他网页编入索引index 将网页编入索引。这是默认行为，并且可忽略。noodp 不使用 Open Directory Project 来创建内容描述。noydir 不使用 Yahoo Directory 来创建内容描述。noarchive 不允许搜索引擎显示内容的缓存版本。cache 允许搜索引擎显示内容的缓存版本。nocache 不允许搜索引擎显示内容的缓存版本。 为设备添加viewport&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,max-scale=3,minimum-scale=1,user-scale=no &quot;&gt; user-scalable 是否允许用户缩放(yes/no) 如果你的网站不是响应式的，请不要使用 initial-scale 或者禁用缩放:&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=yes&quot;&gt; 适配 iPhone 6 和 iPhone 6plus 则需要写： 12&lt;meta name=&quot;viewport&quot; content=&quot;width=375&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=414&quot;&gt; rss订阅&lt;meta rel=&quot;alternatite&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;&gt; favicon&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;图标地址&quot; &gt; 关闭chrome浏览器下翻译插件&lt;meta name=google&quot; value=&quot;notranslate&quot;&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset=&apos;utf-8&apos;&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html5和html4的区别]]></title>
      <url>%2F2017%2Fhtml5%E5%92%8Chtml4%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[参考1.html5的元素：http://www.w3school.com.cn/tags/tag_menu.asp html5的目标 解决浏览器的兼容性 使得文档结构清晰 为Web应用提供API html5的语法改动1.可以省略标记的元素不允许写结束标记的元素：area、base、br、col、command、hr、img、input、link…可以省略结束标记的元素：li、dt、p、option、tbody、tr、tfoot…可以省略全部标记的元素：html、head、body、colgroup、tbody 2.具有bolean值的属性有些属性不指定属性值时，表示属性值为true，如果想使得属性值为false，可以不使用该属性值。表示属性值为true可以有几种方式：属性名设置为属性值或者空字符串设置为属性值。&lt;input type=&quot;checkbox&quot; checked&gt;//表示checked为true&lt;input type=&quot;checkbox&quot;&gt; //表示chencked为false 3.省略引号html5中，当属性值不包含空字符串、&lt;、&gt;、=、单引号、双引号等字符时，属性值可以不用引号括起来。&lt;input type=text&gt; 新增的元素和废除的元素新增的结构元素1.&lt;section&gt;适合用于章节、标签切换效果的每一个tab容器或论文中有编号的地方，也可以用于网站主页中划分简介、新闻、联系信息等板块2.article表示页面中一块与上下文不相关的独立内容3.aside与article内容相关的辅助信息4.header标题5.hgroup将标题及其子标题进行分组。6.footer脚部7.nav导航8.figure独立的流内容。一般表示文档主题流内容的一个独立单元1234&lt;figure&gt; &lt;figcaption&gt;标题&lt;/figcaption&gt; &lt;p&gt;内容xxxxxxxxxxxxxxxxxxx&lt;/p&gt;&lt;/figure&gt; 新增的其他元素1.video视频1&lt;video src=&quot;./movie.mp4&quot; controls=&quot;controls&quot;&gt; video元素&lt;/video&gt; 2.audio 音乐1&lt;audio src=&quot;ext.mp3&quot;&gt; audio元素&lt;/audio&gt; 3.embed插入各种多媒体1&lt;embed src=&quot;hor.wav&quot; /&gt; 4.mark 向用户呈现那些需要突出显示或高亮的文字。例如在搜索结果中向用户高亮显示搜索关键词&lt;mark&gt;&lt;/mark&gt; 5.progress 表示运行中的进程，可以用来显示js中消耗时间的函数的进程1&lt;meter value=&quot;0.6&quot;&gt;60%&lt;/meter&gt; 显示60%的进度条 6.time 时间&lt;time&gt;&lt;/time&gt; 7.ruby 表示ruby的注释8.wbr 软换行与br的区别是：当浏览器宽度足够宽时，不进行换行 9.canvas 画布它把一个绘图API展示给js，以使脚本能够把想绘制的东西绘制到这块画布上。 12345678910&lt;canvas id="myCanvas"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt;var canvas=document.getElementById('myCanvas');var ctx=canvas.getContext('2d');ctx.fillStyle='#FF0000';ctx.fillRect(0,0,80,100);&lt;/script&gt; Canvas.getContext(contextID)参数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是 “2d”，它指定了二维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图 API。 10.details 细节信息配合summary使用,summary提供标题或者图例，summary元素时可见的，点击summary元素时会显示details的细节信息1234&lt;details&gt; &lt;summary&gt;HTML5&lt;/summary&gt; this is a a details&lt;/details&gt; 11.menu 菜单列表1234&lt;menu&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt;&lt;/menu&gt; 新增input元素提交的时候自动检查是否符合要求12345&lt;input type="date" name="user_date"&gt; &lt;input type="range" min="1" max="10"&gt; &lt;input type="number"&gt; &lt;input type="email" value=""&gt; &lt;input type="url"&gt; html5废除的元素1.不再使用frame框架，只支持iframe框架 新增的属性表单相关的属性1.autofocus属性：可以对input(type=text)、select、textarea、button元素指定autofocus属性，使得自动获得焦点：&lt;input type=&quot;text&quot; name=&quot;user_name&quot; autofocus=&quot;autofocus&quot; /&gt;2.placeholder属性：input(type=text)与textarea的属性。用户提示，框内默认显示的文字3.form属性：对input、output、select、textarea、button、filedside指定form属性，声明它时属于哪个表单，这样可以不必将它放在表单内，放在页面任何位置都可以。4.required属性：input(type=text)、textarea拥有。表示在用户提交的时候进行检查该元素必填。5.novalidate 属性:form属性，表示在表单提交时不进行验证。6.input属性： readonly属性:input，规定输入字段为只读，不能修改。 disabled属性 ：input，禁用。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。该属性不需要值。 size属性：input，输入字段的字符数。 maxlength属性：最大长度 autocomplete 属性：规定表单或输入字段是否应该自动完成。autocomplete=”on”，当自动完成开启，浏览器会基于用户之前的输入值自动填写值。autocomplete 属性适用于&lt;form&gt; 以及如下 &lt;input&gt;类型：text、search、url、tel、email、password、datepickers、range 以及 color。 formaction属性：适用于input(type=submit,type=image)、button。formaction 属性覆盖 元素的 action 属性。 list属性：list 属性引用的 &lt;datalist&gt; 元素中包含了&lt;input&gt; 元素的预定义选项 123456789&lt;input list="browsers"&gt;&lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt;&lt;/datalist&gt; min 和 max 属性min 和 max 属性规定 &lt;input&gt; 元素的最小值和最大值。min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。&lt;input type=&quot;date&quot; name=&quot;bday&quot; max=&quot;1979-12-31&quot;&gt; multiple 属性multiple 属性是布尔属性。如果设置，则规定允许用户在 &lt;input&gt; 元素中输入一个以上的值。multiple 属性适用于以下输入类型：email 和 file。&lt;input type=&quot;file&quot; name=&quot;img&quot; multiple&gt; pattern 属性pattern 属性规定用于检查 &lt;input&gt; 元素值的正则表达式。pattern 属性适用于以下输入类型：text、search、url、tel、email、and password。 1&lt;input type="text" name="country_code" pattern="[A-Za-z]&#123;3&#125;" title="错误提示"&gt; step 属性step 属性规定 &lt;input&gt; 元素的合法数字间隔。 链接相关属性 为a与area元素添加了media属性。 为area元素添加hreflang属性与rel属性 为link元素添加sizes新属性 为base元素添加target属性 其他属性 为ol元素添加reversed属性，指定列表倒序显示 为menu元素增加两个新属性：type和label 为style增加scoped属性。如果使用该属性，则样式仅仅应用到 style 元素的父元素及其子元素。 为script增加async属性。async 属性规定一旦脚本可用，则会异步执行。注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。注释：有多种执行外部脚本的方法：如果 async=”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）如果不使用 async 且 defer=”defer”：脚本将在页面完成解析时执行如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本、 为html元素增加manifest属性 为iframe元素增加sandbox、seamless、srcdoc属性(后两个浏览器还没实现)，提高页面安全性&lt;iframe src=&quot;http://alibaba.com&quot; sandbox&gt;,sandbox后面如果不加任何值，就代表采用默认的安全策略，即：iframe的页面将会被当做一个独自的源，同时不能提交表单，以及执行JavaScript脚本，也不能让包含iframe的父页面导航到其他地方，所有的插件，如flash,applet等也全部不能起作用。简单说iframe就只剩下一个展示的功能 废除的属性align：(div、h1..、p)。使用css替代其他不列举了 。总之是希望样式都放到css中去 全局属性contentEditable功能是允许用户编辑元素中的内容 designMode用来指定整个页面是否可编辑，该属性只能子啊js里被修改.为on时，上面的contentEditable属性的元素都变成了可编辑状态。 hiddenhtml5中所有元素都允许使用hidden属性。可以用js使得该隐藏的元素显示。 spellcheckhtml5针对input(type=text)元素与textarea新增。作用时对用户输入的文本内容进行拼写和语法检查。spellcheck属性必须设为true才有效。如果元素的readonly属性或者disable属性设置为true，则不执行拼写检查。 tabindexTab键让页面中的控件获得焦点，tabindex值表示该控件时第几个被访问到的。如果你不想某个已经focus的元素使用tab获得焦点，可以把该元素的tabindex值设置为负数，通常设置为-1 新增的主体结构元素article元素12345678910&lt;article&gt; &lt;header&gt; &lt;h1&gt;苹果&lt;/h1&gt; &lt;p&gt;发表日期：&lt;time pubdate="pubdate"&gt;2017-06-22&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;&lt;b&gt;苹果&lt;/b&gt;植物类水果...&lt;/p&gt; &lt;footer&gt; &lt;p&gt;&lt;small&gt;版权所有，翻版搞死你&lt;/small&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; aiticle可以嵌套，内容要相关联：123456789101112131415&lt;article&gt; &lt;header&gt;...&lt;/header&gt; &lt;p&gt;...&lt;/p&gt; &lt;section&gt; &lt;h2&gt;...&lt;/h2&gt; &lt;article&gt; &lt;header&gt;...&lt;/header&gt; &lt;p&gt;...&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt;...&lt;/header&gt; &lt;p&gt;...&lt;/p&gt; &lt;/article&gt; &lt;/section&gt;&lt;/article&gt; section元素section元素用于页面上内容进行分块，通常由内容及其标题组成。1234&lt;section&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;内容&lt;/p&gt;&lt;/section&gt; aside元素用来表示页面附属信息部分，例如：侧边栏、广告、导航条等 pubdate布尔值属性，代表网页的发布日期 表单与文件input类型1.url类型2.email类型3.date类型：选择年月日4.datetime类型：专门输入UTC时间的文本框，提交时会对输入的日期进行检查。5.datetime-local类型：专门用来输入本地日期和时间的文本框，提交时会验证。6.month、week类型7.number类型：有min、max、step属性8.range类型：有min、max、step属性。用滑条形式显示9.search类型：专门用来输入搜索关键词的文本框10.tel类型：电话号码。没有特殊的校验规则，通过pattern属性来验证。11.color类型：提供一个颜色选取器 表单验证1.自动验证： required属性：必填 pattern属性：正则表达式 min、max属性：输入数值或日期范围 step属性：步幅 2.取消验证 使用form的novalidate属性，整个form里的元素的验证都失效 使用input的formnovalidate属性,使得单个input元素验证失效 文件file对象 file对象有两个属性： name：文件名，不包括路径 lastModifiedDate：最后修改日期file还继承了Blob对象的两个属性size和type，size表示文件的大小，type表示文件类型，类型嗾使以“image/”开头 FileReader接口作用是把文件读入内存，并且读取文件中的数据。检查浏览器是否支持改接口方法： 12345if(typeof FileReader=='undefined') &#123;alert("未实现");&#125; else&#123; var reader=new FileReader(); &#125; 接口使用* 接口事件 拖放API1.drag and drop事件流程一个完整的drag and drop流程通常包含以下几个步骤: 设置可拖拽目标.设置属性draggable=”true”实现元素的可拖拽. 监听dragstart设置拖拽数据 为拖拽操作设置反馈图标(可选) 设置允许的拖放效果,如copy,move,link 设置拖放目标,默认情况下浏览器阻止所有的拖放操作,所以需要监听dragenter或者dragover取消浏览器默认行为使元素可拖放. 监听drop事件执行所需操作 2.拖拽事件以下是拖拽产生的一系列事件,拖拽事件产生时不会产生对应的鼠标事件. dragstart:拖拽开始时在被拖拽元素上触发此事件,监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件. dragenter:拖拽鼠标进入元素时在该元素上触发,用于给拖放元素设置视觉反馈,如高亮 dragover:拖拽时鼠标在目标元素上移动时触发.监听器通过阻止浏览器默认行为设置元素为可拖放元素. dragleave:拖拽时鼠标移出目标元素时在目标元素上触发.此时监听器可以取消掉前面设置的视觉效果. drag:拖拽期间在被拖拽元素上连续触发 drop:鼠标在拖放目标上释放时,在拖放目标上触发.此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为. dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.将元素从浏览器拖放到操作系统时不会触发此事件. 3.DataTransfer对象拖拽事件周期中会初始化一个DataTransfer对象,用于保存拖拽数据和交互信息.以下是它的属性和方法： dropEffect: 拖拽交互类型,通常决定浏览器如何显示鼠标光标并控制拖放操作.常见的取值有copy,move,link和none effectAllowed: 指定允许的交互类型,可以取值:copy,move,link,copyLink,copyMove,limkMove, all, none默认为uninitialized(允许所有操作) files: 包含File对象的FileList对象.从操作系统向浏览器拖放文件时有用. types: 保存DataTransfer对象中设置的所有数据类型. setData(format, data): 以键值对设置数据,format通常为数据格式,如text,text/html getData(format): 获取设置的对应格式数据,format与setData()中一致 clearData(format): 清除指定格式的数据 setDragImage(imgElement, x, y): 设置自定义图标 dataTransfer对象在传递给监听器的事件对象中可以访问,如下:123draggableElement.addEventListener('dragstart', function (event) &#123; event.dataTransfer.setData('text', 'Hello World');&#125;, false); 画图画矩形先设置颜色，再勾勒形状1.取得canvas元素2.取上下文:context3.设定绘图样式：填充fillStyle 边框strokeRect4.绘制形状:context.fillRect(x,y,width,height)123456var context= document.getElementById("canvasId"); context.fillStyle="red";//填充颜色 context.strokeStyle="blue";//外边框颜色 context.lineWidth=10;//线宽度 context.fillRect(50,50,100,100);//画填充 context.strokeRect(50,50,100,100);//画边框 使用路径fill() 填充当前绘图（路径）stroke() 绘制已定义的路径beginPath() 起始一条路径，或重置当前路径 绘制圆形先勾勒图形轮廓，再设置颜色。和上面的相反1.取得canvas元素2.取得上下文3.创建路径 context.beginPath()4.创建图形 context.arc(x,y,半径,起始角度，结束角度，是否逆时针画)5.路径创建完后关闭路径 context.closePath()6.设定绘制样式 context.fillStyle context.fill() 绘制直线1.moveTo(x,y) 将光标移动到指定坐标点，直线可以以这个为起点2.lineTo(x,y) 直线终点 光标在哪里那里就是直线的起点。lineTo的坐标是下一个直线的起点。 颜色渐变1234var g1=context.createLinearGradient(xStart,yStart,xEnd,yEnd);g1.addColorStop(0,'#000');g1.addColorStop(1,'#fff');context.fillStyle=g1;//把fillStyle设置为LineearGradient对象 坐标变换1.平移：context.translate(x,y)2.放大：context.scale(x,y)3.旋转：context.rotate(angle) canvas绘制视频1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;要使用的视频：&lt;/p&gt;&lt;video id="video1" controls width="270" autoplay&gt; &lt;source src="/example/html5/mov_bbb.mp4" type='video/mp4'&gt; &lt;source src="/example/html5/mov_bbb.ogg" type='video/ogg'&gt; &lt;source src="/example/html5/mov_bbb.webm" type='video/webm'&gt;&lt;/video&gt;&lt;p&gt;画布（每 20 毫秒，代码就会绘制视频的当前帧）：&lt;/p&gt;&lt;canvas id="myCanvas" width="270" height="135" style="border:1px solid #d3d3d3;"&gt;Your browser does not support the HTML5 canvas tag.&lt;/canvas&gt;&lt;script&gt;var v=document.getElementById("video1");var c=document.getElementById("myCanvas");ctx=c.getContext('2d');v.addEventListener('play', function() &#123;var i=window.setInterval(function() &#123;ctx.drawImage(v,0,0,270,135)&#125;,20);&#125;,false);v.addEventListener('pause',function() &#123;window.clearInterval(i);&#125;,false);v.addEventListener('ended',function() &#123;clearInterval(i);&#125;,false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工具推荐：小书匠+印象笔记]]></title>
      <url>%2F2017%2F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%EF%BC%9A%E5%B0%8F%E4%B9%A6%E5%8C%A0%2B%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0.html</url>
      <content type="text"><![CDATA[[TOC] 小书匠小书匠书一个使用markdown简单语法书写笔记的软件，同时可以将笔记同步到github、印象笔记、有道云笔记这些云端，这样可以实现不同电脑笔记的同步（只要你每台电脑绑定同一个印象笔记） 还可以将笔记到处为各种格式的文件： 我的个性设置： 印象笔记印象笔记空间大小不限制，每个月上传流量限制一百兆左右吧，放心，每个月都用不完的。 markdown语法掌握一般常用的就行:123456789# 一级标题注意文字和#之间有空格## 二级标题`` 中间包含文字是将字弄成标签* XX 是分点还有代码块是用两个```包括起来 具体的小书匠中有示范，或者直接百度markdown语法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[yii2 gii]]></title>
      <url>%2F2017%2Fyii2%20gii.html</url>
      <content type="text"><![CDATA[[TOC] 生成model CRUD前台生成： 生成后台的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mariadb集群]]></title>
      <url>%2F2017%2Fmariadb%E9%9B%86%E7%BE%A4.html</url>
      <content type="text"><![CDATA[[TOC] 前期工作 默认已经按官方的搭建好了mariadb数据库 主机规划：`10.108.210.212` node1 `10.108.204.191` node2 `10.108.207.93` node3 共用数据库kaa 账号密码 kaacluster 123456（三个数据库都创建个这个账号）1.运行 mysql_secure_installation配置MariaDB我们可以根据自己的需求进行配置定义2.给远程账户运行权限：在mysql下运行12GRANT ALL PRIVILEGES ON *.* TO 'kaacluster'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;flush privileges; 集群1.我们首先登陆到Mysql主服务器node1上，然后编辑mysql的配置文件 1sudo vim /etc/my.cnf.d/server.cnf 我们要添加以下内容； 注：一定要加入到加到mysqld下面，如果加入的位置或者信息不对的话，执行show master status;结果为空； 12345678#设置服务器ID,为1的表示为主服务器；如果服务器没有以下配置，添加，如果有就跳过。server-id=1#启动MySQ二进制日志系统，注意：如果原来的配置文件中已经有这一行，就不用再添加了。log_bin=mysql-bin#需要同步的数据库名，如果有多个数据库，可重复此参数，每个数据库一行\binlog-do-db=kaa#不同步mysql系统数据库binlog-ignore-db=mysql 2.重启mysql服务 1sysmtectl restart mariadb 3.进入mysql控制台 1mysql -u kaacluster -p 123456 查看数据库主机的配置文件状态 1show master status;#mysql中执行 查看主服务器，出现以下类似信息；如果看不见以下结果或者为空的话，说明my.cnf配置文件配置的有问题，请检查即可。 注意：这里记住File的值：mysql-bin.00000x和Position的值：245，后面会用到。 4.有了主服务器的mysql主机配置后，我需要在从服务器上进行配置了 配置MySQL从服务器的同样文件;区别就是server-id不一样 1sudo vim /etc/my.cnf.d/server.cnf 我们要添加以下内容； 注：一定要加入到加到mysqld下面，如果加入的位置或者信息不对的话，执行show master status;结果为空； 12345678#设置服务器ID,为1的表示为主服务器；如果服务器没有以下配置，添加，如果有就跳过。server-id=2#启动MySQ二进制日志系统，注意：如果原来的配置文件中已经有这一行，就不用再添加了。log_bin=mysql-bin#需要同步的数据库名，如果有多个数据库，可重复此参数，每个数据库一行\binlog-do-db=kaa#不同步mysql系统数据库binlog-ignore-db=mysql 5.接下来配置slave，进入从服务器的mysql控制台配置下： 12mysql -u kaacluster -p #进入MySQL控制台slave stop; #停止slave同步进程 6.接下来通过以下命令来配置主从关系了；以下命令是在从服务器上操作的。 12change master to master_host='10.108.201.212',master_user='kaacluster',master_password='123456',master_log_file='mysql-bin.000009' ,master_log_pos=254;#mysql中执行 里面填写的信息是是在主服务器上执行show master status;的信息 启动slave1slave start; 最后我们查看主从同步是否正常 1show slave status;#mysql中执行 测试最后我们测试数据，给主服务器数据表添加数据，可以在从服务器上看到数据库更新 出现的问题解决连不上解决：这个原因是因为防火墙的问题在mysql服务端执行service iptables stop 主库空间问题，日志被截断出现报错：Got fatal error 1236 from master when reading data from binary log: ‘binlog truncated in the middle of event; consider out of disk space on master; the start event position from ‘mysql-bin.006730’ at 290066434, the last event was read from ‘/u01/my3309/log/mysql-bin.006730【原因】 该错误和主库的空间问题和sync_binlog配置有关，当主库 sync_binlog=N不等于1且磁盘空间满时,MySQL每写N次binary log，系统才会同步到磁盘，但是由于存储日志的磁盘空间满而导致MySQL 没有将日志完全写入磁盘，binlog event被截断。slave 读取该binlog file时就会报错”binlog truncated in the middle of event;” 当sync_binlog 的默认值是0，像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统来刷新binary log。 当sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步到磁盘中去。【如何解决】 在从库重新指向到主库下一个可用的binlog file 并且从binlog file初始化的位置开始stop slave;change master to master_log_file=’mysql-bin.006731’, master_log_pos=4;start slave; 问题：Last_IO_Error: Master command COM_REGISTER_SLAVE failed: Access denied for user ‘kaacluster’@’10.108.204.191’ (using password: YES) (Errno: 1045)解决：在主服务器上,设置一个从数据库的账户,使用REPLICATION SLAVE赋予权限 mysql&gt; grant replication slave on . to ‘数据库账号’@’192.168.254.153’ identified by ‘数据库密码’;然后在从服务器上stop slave; start slave;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[easypanel扩展php版本]]></title>
      <url>%2F2017%2Feasypanel%E6%89%A9%E5%B1%95php%E7%89%88%E6%9C%AC.html</url>
      <content type="text"><![CDATA[[TOC] 去PHP官网下载php，以及vc11php5.6需要VC支持 安装下载php源码，解压并放在kangle目录下的ext，把帮下载的php解压后，复制目录下的所有文件到ext/php56/php 下注意，解压的php是复制这些文件 将上图php源码解压的所有文件放到php文件夹 最后记得到easypanel面板重启kangle 结果图： 注：其他的php版本也可以类似集成到easypanel，只需要修改下config.xml文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装easypanel+kangle]]></title>
      <url>%2F2017%2F%E5%AE%89%E8%A3%85easypanel%2Bkangle.html</url>
      <content type="text"><![CDATA[[TOC]我的安装环境是windows服务器参考： kangle web搭建：https://www.kangleweb.com/thread-23884-1-1.html 我安装包放都到仓库去了：https://git.coding.net/wangwangwang123/store.git 安装mysql直接百度mysql，然后下载.msi文件直接在windows上安装，没什么难度，就不赘述。 安装kangle安装包是kangle-3.4.8-x64,安装包可以到我的仓库直接搜索名字.直接一步步安装完就行，然后在浏览器输入：你服务器IP：3311/admin初始安装登陆帐号： admin 密码： kangle 安装easypanel参考：https://www.kangleweb.com/thread-5896-1-1.html 先安装ep-2.6.17-x64这个吧(这个集成的是php5.2环境)。一步步往下就行 登陆easypanel面板的地址是：你服务器IP：3312/admin，默认的登陆账号密码也是admin 密码： kangle。进去就改吧，easypanel和kangle的密码会同步修改的 对接数据库,填下面这些项就行，然后点击提交 扩展php版本注：php5.6以上版本需要有vc运行库环境支持 ep-php-5.3.18文件是php5.3的版本插件，直接安装就行，在easypanel里能直接读取到 easypanel的php5.5插件:http://7xwzko.com1.z0.glb.clouddn.com/tpl_php55.zip php5.6安装方法：https://www.kanglesoft.com/forum.php?mod=viewthread&amp;tid=48446&amp;highlight=php5.6或者可以参考我的另外一篇easypanel扩展php版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[api生成二维码]]></title>
      <url>%2F2017%2Fapi%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
      <content type="text"><![CDATA[[TOC]1.百度api： 123$content = urlencode($content);//要生成二维码的内容$image = '&lt;img src="http://pan.baidu.com/share/qrcode?w=150&amp;h=150&amp;url='.$content.'" /&gt;';return $image; 2.其他接口：照样子改就行 http://b.bshare.cn/barCode?site=weixin&amp;url=http://lanyes.orghttp://s.jiathis.com/qrcode.php?url=http://lanyes.orghttp://www.kuaizhan.com/common/encode-png?large=true&amp;data=http://lanyes.org]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OM2M灯泡实例]]></title>
      <url>%2F2017%2FOM2M%E7%81%AF%E6%B3%A1%E5%AE%9E%E4%BE%8B.html</url>
      <content type="text"><![CDATA[[TOC] 参考：http://wiki.eclipse.org/OM2M/one/Web_Interface 启动灯泡插件 首先把IN-CSE和MN-CSE实例启动 在MN-CSE的OSGi控制台上启动灯泡插件，灯泡插件在org.eclipse.om2m.ipe.sample文件中，id=30。在控制台中输入下面命令start 30 1osgi&gt; start 30 然后就会出现灯泡的界面。 在MN-CSE的web界面可以查看灯泡的信息 在web界面可以查看灯泡的state，可以控制灯泡的亮灭。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OM2M对接]]></title>
      <url>%2F2017%2FOM2M%E5%AF%B9%E6%8E%A5.html</url>
      <content type="text"><![CDATA[[TOC]IN-CSE实例和MN-CSE实例的对接。 参考：https://wiki.eclipse.org/OM2M/one/Configuration 配置分别修改两个实例中的configuration/config.ini文件两个实例中基本配置都已经写好了，只需要把两个文件中的org.eclipse.om2m.dbUrl这个数据库参数修改成同一个就行：jdbc\:h2\:./database/db下面贴出我的两个配置文件： 1234567891011121314151617181920212223242526272829#IN-CSE#Wed May 03 17:09:16 GMT+08:00 2017log4j.configuration=file\:./log4j.configurationorg.eclipse.equinox.http.jetty.http.port=8080org.eclipse.om2m.dbReset=falseorg.eclipse.om2m.cseBaseContext=/org.eclipse.om2m.globalContext=osgi.bundles=reference\:file\:javax.servlet_3.1.0.v20140303-1611.jar@4,reference\:file\:javax.xml_1.3.4.v201005080400.jar@4,reference\:file\:org.apache.commons.codec_1.6.0.v201305230611.jar@4,reference\:file\:org.apache.commons.logging_1.1.1.v201101211721.jar@4,reference\:file\:org.apache.felix.gogo.command_0.10.0.v201209301215.jar@4\:start,reference\:file\:org.apache.felix.gogo.runtime_0.10.0.v201209301036.jar@4\:start,reference\:file\:org.apache.felix.gogo.shell_0.10.0.v201212101605.jar@4\:start,reference\:file\:org.apache.httpcomponents.httpclient_4.3.6.v201411290715.jar@4,reference\:file\:org.apache.httpcomponents.httpcore_4.3.3.v201411290715.jar@4,reference\:file\:org.eclipse.equinox.console_1.1.0.v20140131-1639.jar@4\:start,reference\:file\:org.eclipse.equinox.http.jetty_3.0.200.v20131021-1843.jar@1\:start,reference\:file\:org.eclipse.equinox.http.servlet_1.1.500.v20140318-1755.jar@4,reference\:file\:org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar@4,reference\:file\:org.eclipse.jetty.continuation_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.http_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.io_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.security_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.server_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.servlet_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.util_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.om2m.binding.coap_1.0.0.20170503-0856.jar@2\:start,reference\:file\:org.eclipse.om2m.binding.http_1.0.0.20170503-0856.jar@2\:start,reference\:file\:org.eclipse.om2m.binding.mqtt_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.binding.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.commons_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.commons.logging_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.core_1.0.0.20170503-0856.jar@4\:start,reference\:file\:org.eclipse.om2m.core.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.datamapping.jaxb_1.0.0.20170503-0856.jar@1\:start,reference\:file\:org.eclipse.om2m.datamapping.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.interworking.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.persistence.eclipselink_1.0.0.20170503-0856.jar@2\:start,reference\:file\:org.eclipse.om2m.persistence.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.webapp.resourcesbrowser.xml_1.0.0.20170503-0856.jar@4\:start,reference\:file\:org.eclipse.osgi.services_3.4.0.v20140312-2051.jar@4org.eclipse.om2m.cseBaseProtocol.default=httporg.eclipse.om2m.cseBaseName=in-nameorg.eclipse.om2m.cseBaseAddress=127.0.0.1eclipse.p2.profile=DefaultProfileorg.eclipse.om2m.dbUrl=jdbc\:h2\:./database/dbosgi.framework.extensions=org.eclipse.om2m.webInterfaceContext=/webpageosgi.bundles.defaultStartLevel=4org.eclipse.om2m.dbUser=om2mosgi.framework=file\:plugins/org.eclipse.osgi_3.10.2.v20150203-1939.jarorg.eclipse.om2m.guestRequestingEntity=guest\:guestorg.eclipse.om2m.cseBaseId=in-cseorg.eclipse.om2m.dbDriver=org.h2.Driverorg.eclipse.om2m.adminRequestingEntity=admin\:adminorg.eclipse.om2m.cseType=IN-CSEorg.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLoggereclipse.p2.data.area=@config.dir/../p2org.eclipse.om2m.resource.idseparator=-org.eclipse.om2m.coap.port=5683org.eclipse.om2m.dbPassword=om2morg.eclipse.om2m.m2mSpId=om2m.org 12345678910111213141516171819202122232425262728293031323334#MN-CSE#Wed May 03 17:09:19 GMT+08:00 2017org.eclipse.om2m.remoteCseId=in-cselog4j.configuration=file\:./log4j.configurationorg.eclipse.equinox.http.jetty.http.port=8181org.eclipse.om2m.dbReset=falseorg.eclipse.om2m.remoteCsePort=8080org.eclipse.om2m.cseBaseContext=/org.eclipse.om2m.globalContext=osgi.bundles=reference\:file\:javax.servlet_3.1.0.v20140303-1611.jar@4,reference\:file\:javax.xml_1.3.4.v201005080400.jar@4,reference\:file\:org.apache.commons.codec_1.6.0.v201305230611.jar@4,reference\:file\:org.apache.commons.logging_1.1.1.v201101211721.jar@4,reference\:file\:org.apache.felix.gogo.command_0.10.0.v201209301215.jar@4\:start,reference\:file\:org.apache.felix.gogo.runtime_0.10.0.v201209301036.jar@4\:start,reference\:file\:org.apache.felix.gogo.shell_0.10.0.v201212101605.jar@4\:start,reference\:file\:org.apache.httpcomponents.httpclient_4.3.6.v201411290715.jar@4,reference\:file\:org.apache.httpcomponents.httpcore_4.3.3.v201411290715.jar@4,reference\:file\:org.eclipse.equinox.console_1.1.0.v20140131-1639.jar@4\:start,reference\:file\:org.eclipse.equinox.http.jetty_3.0.200.v20131021-1843.jar@1\:start,reference\:file\:org.eclipse.equinox.http.servlet_1.1.500.v20140318-1755.jar@4,reference\:file\:org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar@4,reference\:file\:org.eclipse.jetty.continuation_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.http_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.io_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.security_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.server_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.servlet_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.jetty.util_8.1.16.v20140903.jar@4,reference\:file\:org.eclipse.om2m.binding.http_1.0.0.20170503-0856.jar@2\:start,reference\:file\:org.eclipse.om2m.binding.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.commons_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.commons.logging_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.core_1.0.0.20170503-0856.jar@4\:start,reference\:file\:org.eclipse.om2m.core.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.datamapping.jaxb_1.0.0.20170503-0856.jar@1\:start,reference\:file\:org.eclipse.om2m.datamapping.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.interworking.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.ipe.sample_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.persistence.eclipselink_1.0.0.20170503-0856.jar@2\:start,reference\:file\:org.eclipse.om2m.persistence.service_1.0.0.20170503-0856.jar@4,reference\:file\:org.eclipse.om2m.webapp.resourcesbrowser.xml_1.0.0.20170503-0856.jar@4\:start,reference\:file\:org.eclipse.osgi.services_3.4.0.v20140312-2051.jar@4org.eclipse.om2m.cseBaseProtocol.default=httporg.eclipse.om2m.cseBaseName=mn-nameorg.eclipse.om2m.cseBaseAddress=127.0.0.1eclipse.p2.profile=DefaultProfileorg.eclipse.om2m.dbUrl=jdbc\:h2\:./database/dbosgi.framework.extensions=org.eclipse.om2m.webInterfaceContext=/webpageosgi.bundles.defaultStartLevel=4org.eclipse.om2m.dbUser=om2morg.eclipse.om2m.maxNrOfInstances=1000osgi.framework=file\:plugins/org.eclipse.osgi_3.10.2.v20150203-1939.jarorg.eclipse.om2m.guestRequestingEntity=guest\:guestorg.eclipse.om2m.remoteCseName=in-nameorg.eclipse.om2m.cseBaseId=mn-cseorg.eclipse.om2m.remoteCseContext=/org.eclipse.om2m.dbDriver=org.h2.Driverorg.eclipse.om2m.remoteCseAddress=127.0.0.1org.eclipse.om2m.adminRequestingEntity=admin\:adminorg.eclipse.om2m.cseType=MNorg.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLoggerorg.eclipse.om2m.cseAuthentication=trueeclipse.p2.data.area=@config.dir/../p2org.eclipse.om2m.coap.port=5684org.eclipse.om2m.dbPassword=om2m 运行然后将IN-CSE和MN-CSE都运行起来（在OM2M安装里有介绍怎么运行），到http://127.0.0.1:8080/webpage 中可以在IN-CSE实例中查看到MN-CSE实例。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OM2M安装]]></title>
      <url>%2F2017%2FOM2M%E5%AE%89%E8%A3%85.html</url>
      <content type="text"><![CDATA[[TOC] 本文搭建硬件环境1.windows10系统 java环境配置 用eclipse建立项目 下载Eclipse for RCP and RAP Developers：https://eclipse.org/downloads/packages/eclipse-rcp-and-rap-developers/lunasr2 maven安装： 下载地址：http://maven.apache.org/download.cgi（下载apache-maven-3.5.0-bin.zip文件） 新建环境变量MAVEN_HOME:F:\maven\apache-maven-3.5.0(maven所在路径)在PATH里加入maven的bin的路径：%MAVEN_HOME%\bin 运行mvn -v检验是否配置成功 配置 F:\maven\apache-maven-3.5.0\conf文件夹下的 setting.xml 配置文件：找到localRepository标签，将其修改为： F:/maven/repository;将setting.xml文件copy到F:/maven/repository文件夹下。 eclipse下选择“ Window -&gt; Preferences -&gt; Maven -&gt; User settings”修改你的settings.xml文件位置： 3.安装Tycho插件 Click Window -&gt; Preferences -&gt; maven -&gt; discovery -&gt; open catalog and type Tycho. Check the “Tycho Configurator” checkbox. 4.Clone OM2M using Eclipse Select Window-&gt;Show View -&gt; Other-&gt;git 到eclipse左下角窗口上选择“Clone a Git repository”， Clone the OM2M project using the following link: http://git.eclipse.org/gitroot/om2m/org.eclipse.om2m.git. In the first page, enter the mentioned link in the URI’s location field. 点击NEXT 选中master，再点击next 选中“import all existing projects after clone finishes”，点击finish。等待clone完。 5.Build OM2M using Eclipse 在左上角的“package explorer”窗口的“org.eclipse.om2m”文件包上右键选择“Run as -&gt; maven install” 等待build完期间要等待很长一段时间（半下午），会自动下载很多包。最后success图如下： OM2M测试1.到文件夹”org.eclipse.om2m/org.eclipse.om2m.site.in-cse/target/products/in-cse/..“一直往下找，找到”start.bat“，双击该文件，会显示下面界面： 2.然后输入ss会进入OSGi console，输入exit关闭。 3.在浏览器输入网址：http://127.0.0.1:8080/webpage 访问IN-CSE Web界面。用户名“admin”和密码“admin”，然后点击登录按钮显示IN-CSE资源树。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OM2M调研]]></title>
      <url>%2F2017%2FOM2M%E8%B0%83%E7%A0%94.html</url>
      <content type="text"><![CDATA[提供参考的网站： www.eclipse.org/om2m https://iot.eclipse.org 论坛：http://www.eclipse.org/forums/eclipse.om2m[TOC]Om2m是一个横向的M2M（machine to machine）服务平台，目的是使得应用开发e和底层网络分离，适配各种异构设备。OM2M提供一些RESTful API来创建和管理M2M资源。 它包括几个程序以实现机器认证，资源发现，应用程序注册，容器管理，同步和异步通信，访问权限授权，组织组织，重定向等 名词解释This API operates on the following primary resource types: CseBase（Common Services Entity）: describes the hosting CSE, and is the root for all other resources within the hosting CSE.(所有资源的根) remoteCse: stores information related to M2M CSEs residing on other M2M machines after successful mutual authentication. It enables Cses interactions using retargeting operations（CSE业务之间交互） AE(Application Entity): stores information about the Application Entity after a successful registration on the hosting CSE.（存应用实体信息） Container: acts as a mediator for data buffering to enable data exchange between applications and CSEs（数据缓存中介容器） AccessControlPolicies: manages permissions and permissions holders to limit and protect the access to the resource tree structure.（访问权限管理） Group: enhances resources tree operations and simplifying the interactions on the API interfaces by adding the grouping feature. It enables an issuer to send one request to a set of receivers instead of sending requests one by one.（群发） Subscription: stores information related to subscriptions for some resources. It allow subscribers to receive asynchronous notification when an event happens such as the reception of new sensor event or the creation, update, or delete of a resource.（通知） 注：CSE(CommonchannelSignalingEquipment),公共信道信令设备.公共信道信令系统提供的几种可能的电信业务之一，用于某种特殊业务进行信息传递。 IN-CSE（Infrastructure Node CSE）:can be seen as a centralized server deployed on the cloud. MN-CSE (Middle Node CSE):can be sees as a gateway deployed locally. MNs has the possibility to register to IN and so enable one to obtain a highly distributed architecture covering various use cases.You can consider an IoT architecture including only one IN if your prefer a centralized architecture, however this use case is not interesting because it requires that all your devices and applications are capable to reach the IN which is not the case for small sensors. The MN can act as a proxy to connect local constrained devices to the IN.You can also consider an IoT architecture including only one MN deployed locally if you don’t need a centralized server, however this is not so recommended because it requires the MN to answer to all coming requests. In general, the MN is a constrained device which may represent a single point of failure in this case. Imagine a use case where your sensors are not deployed on the place which requires more than one MN. In this case, the IN will be the intermediate between all existing MNs.For me, it is better to have a distributed IoT architecture including one IN and several MNs deployed in several places. The IN will be in charge to re-targeting requests from a Node to another in a seamless way. Applications can be deployed on the IN or on the MNs according to your needs. Each node can host customized services like cool dashboard in the IN, or dedicated interworking proxies in the MNs to connect local vendor-specific devices. Mca reference point is used to interface an AE and CSE Mcc reference point is used to interface CSEs 可以有多个IN-CSE OM2M基于JAVA的OSGi框架开发 oneM2M架构 通信流程 M2M通信有以下流程 注册：灯应用实体、网关应用、数据资源的访问权限控制创建 资源初始化：包括分组资源创建、特定访问通道的容器资源创建、实例资源的创建（初始化灯状态）、subscription resources creation for notifications 容器发现：网关检测满足特定过滤条件的容器并将它们编入分组 发现和检索灯的状态：智能手机通过M2M服务平台使用资源认证的方式检索特定过滤条件的容器 控制灯的开关： 上面流程的请求和响应都是通过oneM2M HTTP协议，使用XMXL和JSON传输数据.例如控制关灯的请求：HTTP Request with XML payload12345678910POST /home_gateway/light_ae1/light?rcn=0 HTTP/1.1Host: http://mn.provider.com:8080X-M2M-Origin: Clight_ae1Content-Type: application/vnd.onem2m-res+xml; ty=4X-M2M-RI: mncse-24345&lt;m2m:cin xmlns:m2m="http://www.onem2m.org/xml/protocols"&gt; &lt;cnf&gt;text/plain:0&lt;/cnf&gt; &lt;con&gt;OFF&lt;/con&gt;&lt;/m2m:cin&gt; HTTP Response 1234HTTP/1.1 201 Created X-M2M-RSC: 2001 X-M2M-RI: mncse-24345 Content-Location: /mn-cse/cin-394798749 注册流程 资源创建在MN-CSE中创建container，灯的状态存储在MN-CSE中 容器发现 Discovery &amp; Content Instance Retrieval群容器： light control控制单个灯状态： 群控制:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP实用笔记]]></title>
      <url>%2F2017%2FPHP%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0.html</url>
      <content type="text"><![CDATA[PHP实用笔记php循环取数据到html中21234567891011121314151617181920212223242526272829303132333435363738&lt;?php$goods = array();//从数据库获取商品信息存入$goods二维数组$i = 0;//这里请换上自己的数据库相关信息$conn = mysqli_connect(&apos;localhost&apos;,&apos;username&apos;,&apos;password&apos;,&apos;test&apos;);mysqli_set_charset($conn,&quot;utf8&quot;);$res = mysqli_query($conn,&apos;select * from good&apos;);//这里把商品信息放到$goods二维数组，每一维存的是单个//商品的信息，比如商品称、价格。while ($row = mysqli_fetch_assoc($res)) &#123; $goods[$i][&apos;id&apos;] = $row[&apos;id&apos;]; $goods[$i][&apos;name&apos;] = $row[&apos;name&apos;]; $goods[$i][&apos;price&apos;] = $row[&apos;price&apos;]; $i++ ;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;title&gt;PHP商品展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php//取出商品信息显示在页面上，并添加购买功能foreach ($goods as $value) &#123; echo &apos; 商品名: &apos;. $value[&apos;name&apos;] . &quot; &quot; . &apos; 价格: &apos; . $value[&apos;price&apos;] . &quot; &quot; ; echo &quot;&lt;a href=buy.php?name=&quot; . $value[&apos;name&apos;] . &apos;&amp;price=&apos; . $value[&apos;price&apos;] .&quot;&gt;购买&lt;/a&gt;&quot;; echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;;&#125;?&gt;&lt;a href=&quot;cart.php&quot;&gt;查看您的购物车&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 将图片和商品联系起来商户注册后，用商户id命名创建一个文件夹mkdir（”path/$id”）商户登陆后利用登陆商户的id，在上传图片时，将图片移动至相应的文件夹下可以将商户id存入session或者cookiemove_uploaded_file（file，path/$id/$filename） 1.将上传图片服务独立出来，与具体业务无关，只返回图片的URL2.上传完图片后，将图片的URL写入input hidden域，和创建或更新表单一起提交，在此做保存或更新操作3.数据库表结构设计参考楼上的 不要放图片路径放 图片名字 然后取出来 图片肯定放在一个目录下的然后拼接一下 就行了 引入config.phprequire_once(dirname(dirname(FILE)).”/common/db.php”); 计算库存12345$sql = &quot;select card from faka_stocks where goods_id=&apos;&#123;$idmy&#125;&apos; and status=&apos;NONE&apos;&quot;;$rss = $db-&gt;query($sql);$row_resultss=$db-&gt;affected_rows;?&gt;库存：&lt;?php echo $row_resultss;?&gt; form无刷新提交表单在默认情况下， 提交form表单后， 是有刷新的。 但是， 有的时候， 希望提交表单后不要刷新， 免得把页面已经有的东东给刷跑了， 那怎么搞呢（最近刚好碰到）？ 实例代码如下： 123456789101112&lt;html&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; target=&quot;nm_iframe&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;id_input_text&quot; name=&quot;nm_input_text&quot; /&gt; &lt;input type=&quot;submit&quot; id=&quot;id_submit&quot; name=&quot;nm_submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;iframe id=&quot;id_iframe&quot; name=&quot;nm_iframe&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[yii2 除了主页其他的页面都是404 Not Found]]></title>
      <url>%2F2017%2Fyii2%20%E9%99%A4%E4%BA%86%E4%B8%BB%E9%A1%B5%E5%85%B6%E4%BB%96%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%83%BD%E6%98%AF404%20Not%20Found.html</url>
      <content type="text"><![CDATA[今天在centos搭建yii2好不容易调试出了主页显示，但是除了主页其他的页面都是404 Not Found，很明显是路由问题。yii2官方的的git给出了解决方法： 12345678910111213141516Use the following configuration in Apache's httpd.conf file or within a virtual host configuration. Note that you should replace path/to/basic/web with the actual path for basic/web.# Set document root to be "basic/web"DocumentRoot "path/to/basic/web"&lt;Directory "path/to/basic/web"&gt; # use mod_rewrite for pretty URL support RewriteEngine on # If a directory or a file exists, use the request directly RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d # Otherwise forward the request to index.php RewriteRule . index.php # ...other settings...&lt;/Directory&gt; 这是我服务器上的httpd.conf文件修改的截图： 前台和后台都要添加，添加完路由才正常。不知道为什么非要在apache的配置文件中添加，web目录下的.htaccess不起作用.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NS-3安装]]></title>
      <url>%2F2017%2FNS-3%E5%AE%89%E8%A3%85.html</url>
      <content type="text"><![CDATA[[TOC] 参考文档 官方安装wiki文档：https://www.nsnam.org/wiki/Installation 参考博客：http://blog.csdn.net/dyzok88/article/details/50816624 环境我系统的环境 ubuntu 16.10建议ubuntu 16.04版本以上吧 NS版本ns-3.26 安装依赖 注意：如果提示权限不够，在前面加上sudo。 minimal requirements for C++ (release): This is the minimal set of packages needed to run ns-3 from a released tarball. 1apt-get install gcc g++ python minimal requirements for Python (release): This is the minimal set of packages needed to work with Python bindings from a released tarball. 1apt-get install gcc g++ python python-dev minimal requirements for Python (development): For use of ns-3-allinone repository (cloned from Mercurial), additional packages are needed to fetch and successfully install pybindgen: 1apt-get install mercurial python-setuptools git Python API scanning support: cmake libc6-dev libc6-dev-i386 g++-multilib To rescan Python bindings requires gccxml and pygccxml, which are installed by bake. However, for Ubuntu 16.04, gccxml will not build without a patch and a build flag described here: https://www.nsnam.org/bugzilla/show_bug.cgi?id=2451 qt4 development tools are needed for Netanim animator (Note: qt version qt4, not qt5, is required) 1apt-get install qt4-dev-tools libqt4-dev Support for generating modified python bindings 1apt-get install cmake libc6-dev libc6-dev-i386 g++-multilib and you will want to install gccxml and pygccxml as per the instructions for python bindings (or through the bake build tool as described in the tutorial). Debugging: 1apt-get install gdb valgrind GNU Scientific Library (GSL) support for more accurate WiFi error models 1apt-get install gsl-bin libgsl2 libgsl-dev The Network Simulation Cradle (nsc) requires the flex lexical analyzer and bison parser generator: 1apt-get install flex bison libfl-dev To read pcap packet traces 1apt-get install tcpdump Database support for statistics framework 1apt-get install sqlite sqlite3 libsqlite3-dev Xml-based version of the config store (requires libxml2 &gt;= version 2.7) 1apt-get install libxml2 libxml2-dev A GTK-based configuration system 1apt-get install libgtk2.0-0 libgtk2.0-dev To experiment with virtual machines and ns-3 1apt-get install vtun lxc Support for utils/check-style.py code style check program 1apt-get install uncrustify Doxygen and related inline documentation: 12apt-get install doxygen graphviz imagemagickapt-get install texlive texlive-extra-utils texlive-latex-extra texlive-font-utils texlive-lang-portuguese dvipng The ns-3 manual and tutorial are written in reStructuredText for Sphinx (doc/tutorial, doc/manual, doc/models), and figures typically in dia (also needs the texlive packages above): 1apt-get install python-sphinx dia Note: Sphinx version &gt;= 1.12 required for ns-3.15. To check your version, type “sphinx-build”. To fetch this package alone, outside of the Ubuntu package system, try “sudo easy_install -U Sphinx”. Support for Gustavo Carneiro’s ns-3-pyviz visualizer 1apt-get install python-pygraphviz python-kiwi python-pygoocanvas libgoocanvas-dev ipython Support for openflow module (requires some boost libraries) 1apt-get install libboost-signals-dev libboost-filesystem-dev Support for MPI-based distributed emulation 1apt-get install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev 安装NS-3 下载NS-3安装包：官网首页下载 建立文件夹NS3(可自己定义) 将下载的安装包解压到NS3目录中 编译 1）使用build.py编译 1sudo ./build.py --enable-examples --enable-tests 编译成功： 2）使用waf编译 一旦工程已经编译过，就不能再使用build.py脚本使用waf重新配置和编译ns-3系统 sudo ./waf clean 清除先前配置编译 ./waf -d optimized –enable-examples–enable-tests configure 重新配置ns-3，优化编译例子和测试(默认测试和例子是不编译的)optimized参数，优化模式下默认是禁止ns-3特殊的日志系统（logging），这样导致运行的的结果不能再控制台上显示。因此，建议更改为./waf -d debug --enable-examples --enable-tests configure ./waf 正式编译 3) 运行测试 使用test.py测试，从`ns`目录中进入到`ns-3.26`目录下找到test.py文件，运行： 12cd ns-3.26sudo ./test.py 运行成功： 编程工具安装VIM我比较喜欢vim编辑器，感觉比较原生，你也可以使用eclips，大部分是截取i前辈的文档，但是他们的x有些下载地址进不去，就自己修改了点。 首先说明一下几个配置文件的作用: vim 文件夹,这个文件夹放置 vim 的配置文件,包括 vim 的插件和 doc文件,ubuntu 下面名字以 . 开始说明默认是隐藏的,如果想看可以进入文件夹所在的目录按 CTRL+H,显示隐藏文件,或者在终端下面输入 ls -a 命令。.vim是自己创建的,放在主文件夹下面。创建过程:首先打开终端,一般默认是主文件夹,也可以输入 cd ~命令进入主文件夹,然后,输入 mkdir .vim 创建文件夹。输入 cd .vim 进入文件夹,创建 plugin, doc, tags 文件夹, plugin 放置的是 vim 的一些插件,文件名后缀是.vim,doc 是插件的帮助文档,tags 放 ctags 生成的 tag 文件(tags 这个可选,可以放在任何位置,只要在.vimrc 文件中设置正确即可)。 vimrc 文件,这个文件里面存储 vim 的配置信息,也是自己创建的,和.vim在同一级目录下。创建过程:打开终端,输入:cd ~,然后输入 vim .vimrc 命令,会出现一个.vimrc 文件的 vim 编辑界面。按 i 键进入编辑模式,在文件里面添加如下命令:filetype plugin indent onset helplang=cnset encoding=utf-8syntax enablesyntax on然后按 esc 键,输入:wq 命令,保存退出! 下面是主要配置环节 ctags安装1sudo apt-get install ctags 太繁琐了，不想写了，留着以后有时间再弄吧。暂时用eclipse吧。 编程工具安装之eclipse安装eclipse12sudo apt-get install eclipsesudo apt-get install eclipse-cdt eclipse与ns-3对接1.新建ns3空工程 FILE-&gt;new-&gt;c++project 2.将原来的ns3文件夹下的ns-3.26文件夹下的内容全复制到eclipse的工作目录下 并且在改目录下使用下面的命令配置项目: 1./waf -d dubug --enable-examples --enable-tests configure 3.设置eclipse中的ns3编译器为waf在eclipse中的`project exploer中的项目文件上右键，选择properties选项，进行如下设置 这时右键点击build project进行编译 4.设置eclipse执行工具使用外部工具选择run-&gt;External Tools-&gt;Externel tools Configuration 然后出现: 5.仿真结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工具收集]]></title>
      <url>%2F2017%2Flinux%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86.html</url>
      <content type="text"><![CDATA[[TOC] BracketsGVimlinux系统截图神器shutter参考安装http://www.cnblogs.com/CZM-/p/5858759.html安装命令sudo apt-get install shutter 强大的功能可以将截图自动上传到空间，可以自由在图片上添加文字 设置shutter快捷键1. 打开 Keyboard 键盘设置 截图快捷键ctr+alt+a]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ primer学习（基础）]]></title>
      <url>%2F2017%2FC%2B%2B%20primer%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html</url>
      <content type="text"><![CDATA[推荐：比较好的在线C++工具：https://www.shucunwang.com/RunCode/cpp/ [TOC] main函数： mian()的返回类型必须是int。 在大多数系统中main的返回值被用来指示状态，返回0表示成功，非0的含义由系统定义。 编译 c++程序通过编译器生成一个可执行文件，windows下是.exe文件，unix下可执行文件是.out（没规定可执行文件名时）。 GNU编译器： 1g++ -o progname progname.cc -o后面的参数是指定生成文件的名字此命令在windows下生成progname.exe文件，在unix系统中生存没有后缀的文件progname，如果unix中没有指定参数-o progname则生成a.out的可执行文件。 const限定符1.基础知识： 程序是不能改变const值的 const对象必须初始化 2.初始化 非const可以初始化const对象： 123int a=1;const int b=a;int c=b; 对于const变量不管是声明还是定义都添加extern关键字，这样在其他文件中都可以共享了定义：extern const int a=1;其他文件中声明:extern const int a; 3.常量引用 const int c=1; const int &amp;ci=c; 程序员把“对const的引用”简称为‘常量引用’。但是严格来说并不存在常量引用，因为引用并不是一个对象，所以没办法让引用本身恒定不变，事实上由于C++并不允许随意改变引用所绑定的对象，所以从这层上理解所有的引用又都算常量。 常量引用可能引用的对象并不是一个const对象：int i=2; const int &amp;b=i; 4.指针和常量 指向常量的指针：想要存放常量对象的地址只能用指向常量的指针const double pi=3.14; 指针的类型必须与它所指向的对象的类型一致，例外：允许一个指向常量的指针指向一个非常量对。指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指向对象的值。 常量指针：把指针本身定义为常量啊，不变的是指针本身的值而非指向的那个值 常量指针int *const my=&amp;a;注： 常量指针必须初始化 指向常量的指针和常量指针的辨别：const int *p:距离p最近的是*意味着p本身是一个指针，指针的类型由声明符的其余部分确定。int *const p距离p最近的是const，意味着p是一个常量对象，对象的类型由声明符的其他部分确定。 顶层const：指针本事是个常量底层const：指针所指的对象是个常量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对接支付接口]]></title>
      <url>%2F2017%2F%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3.html</url>
      <content type="text"><![CDATA[[TOC] 假期的时候对接过几个支付接口：微信官方的支付、天工这些。 支付流程支付宝、微信等则没有API第三方平台这项 关于前端 网站支付前端是用户提交的表单，包含商品的一些信息，这其中需要用到多重验证，防止用户直接在浏览器用审查元素篡改数据、更改提交的价格，惨重的教训啊！！多多注意。 后来我想到了一个很好的验证：用户产生的价格这些数据和存在数据库的对应数据对比下，如果没篡改，就采用session方式存储，post到第三方支付平台时取出这些session数据，减少了中间页面数据被篡改的可能性。 第三方平台为了防止用户篡改数据，采用了签名的方式，根据待提交的交易信息按一定的算法生成一个sign签名一起和交易信息发送给第三方服务端，付完款交易结束，第三方平台采用异步、同步通知返回交易结果信息给商户指定的php文件，这其中又包含了一个sign，这个sign需要和商家发送的sign对比看数据是否被篡改。 最后商家个人网站根据验证服务端返回的信息来决定是否发货啊什么的操作。 关于后端 支付网站数据处理还是采用php比较好（因为我后端语言只会点php啊），php别人是从网站上扒不下来的，感觉php很强大啊。 最近感觉易语言有点意思，打算有空闲时间鼓捣下 哎，我的SDN还没学。感觉假期过得好快啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>%2F2017%2FjQuery.html</url>
      <content type="text"><![CDATA[[TOC] 小知识 js中双引号和单引号基本没区别。 jQuey的CDN&lt;script src=&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;或者&lt;script src=&quot;http://cdn.staticfile.org/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://cdn.staticfile.org/jquery/3.1.1/jquery.min.map&quot;&gt;&lt;/script&gt; 自动执行函数1.$(document).ready(函数体);$(document).ready(function () {函数内容;})；在文档载入完后自动执行 可以用holdReady()方法延迟ready事件触发时间$.holdReady(true);//此处必须在ready触发事件之前调用$(document).ready();…setTimeout(function(){$.holdReady(false);},延迟时间); 2.$(function(){函数内容});也可以自定义 $()，只要将jQuery.noConflict()方法的返回值赋给你自定义的变量即可。 ##jquery函数jquery()或$() 选择器–从DOM中选择元素$(“选择器”) 兼容CSS3选择器。得到的可以看为一个数组下面是juqry选择器： 说明：:first表示选中的结果中元素第一个 :eq(3) 列表中的第4个元素（index 从 0 开始） gt(3) 列出 index 大于 3 的元素 lt(3) 列出 index 小于 3 的元素 基本选择器 实例 解释 #id $(“#lastname”) id=”lastname” 的元素 .class $(“.intro”) 所有 class=”intro” 的元素 element $(“p”) 所有 元素 .class.class $(“.intro.demo”) 所有 class=”intro” 且 class=”demo” 的元素 规定搜索范围选择器$(“选择器”,范围) 这个范围可以是$(“选择器”)得来的 把DOM对象转换成juqery对象在DOM对象外面加$()即可 juqery方法.attr(‘添加的属性’,’属性值’)为对象添加属性和属性值例子：$(“.classMy li img”).attr(“alt” , “picture”) .addClass(‘要增加的类名’)给对象添加指定的类【未完待续】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[User-CentriC Ultra-Dense networks for 5G]]></title>
      <url>%2F2017%2FUser-CentriC%20Ultra-Dense%20networks%20for%205G.html</url>
      <content type="text"><![CDATA[来源：User-CentriC Ultra-Dense networks for 5G: ChallenGes, MethoDoloGies, anD DireCtions Shanzhi Chen, Fei Qin, Bo hu, Xi Li, and zhongLin Chen [TOC] 摘要 UUDN是以用户为中心的UDN，从网络控制用户的理念转变为网络服务用户。 UUDN结合了网络服务用户的理念和蜂窝网的技术 动态AP组是UUDN核心技术 UUDN意在提供移动管理、资源管理、接入管理和安全问题相融合的综合应用 UUDN的目的是更有效的资源优化、更好的用户体验、提高能力利用率 简介随着在线多媒体、移动社交网络、交互游戏、3D动画、虚拟现实等这些互联网服务的发展，将会导致网络流量的拥堵，特别是城市和一些人群密集的地区。区域频谱效率成为了衡量未来移动网络的一项重要的指标，同时它也影响着网络系统的负载。 优化系统负载的三种方法： 寻找更好的调制和信道编码来增加空口的频谱利用率 增加频谱带宽 通过减少蜂窝大小来实现频谱再利用 通过减小蜂窝单元的覆盖范围、增加接入点的密度是一种最有效的方法来提高网络系统的负载。 本文结合5G定义UDN的特征： 高密度的接入点，提供足够多的手机接入 不同种类的接入点，满足不同网络的选择 不同覆盖范围的异构网和多种无线接口技术 本文结构：1.UUDN面临的挑战2.UUDN的一种新的结构及格部分功能3.未来展望 UUDN的概念和面临的挑战UUDN的概念UDN和传统蜂窝网区别： 二者最主要的区别是接入口或者基站的密度，UDN中一平方千米之内可以有上千个接入口，而传统蜂窝网一平方千米之内只有三到五个基站。 接入口的类型不同，UDN中小的基站单元、中继基站、用户端都可以作为接入点。 UUDN定义UUDN结合了网络服务用户的理念和蜂窝网的技术，它是一个接入点与用户密度成比例的无线网络，该网络会智能识别无线用户的通信环境，然后不间断地动态分配接入点组和资源服务每个用户。 UUDN四个特征1.了解用户的智能网络：网络能智能识别用户终端的负载、用户的需求，并且为每个用户构建知识信息。2.跟随用户的移动网络:根据终端的移动动态地调整APG3.服务用户的动态网络：动态调整APG成员来匹配用户的需求，它们协作传输信息流来提高频谱利用率和用户体验4.网络安全认证：接入点认证和用户终端认证 UUDN面临的挑战1.网络结构面临的挑战： 4G的服务控制和移动控制等都集中在核心网，对高吞吐量的UDN来说效率很低 在接入点密度大的空口上用户平面和控制平面的紧耦合在异构网中会带来困难 传统的蜂窝结构很难支持UUDN的APG、前向干扰管理和资源管理，更高层的资源管理和移动管理也很难独立地部署 本地网关的数据传输服务业不支持一些以用户为中心的服务 2.移动管理面临的挑战 传统网络的本地配置是固定死的，本地管理模式将要从固定的AP管理转为动态AP合作 由于不规则的覆盖和相邻用户之间的关系，转发控制也变得很困难了，而且不同类型的接入点也会使得转发控制相当的复杂 移动管理、资源管理、干扰协调者三者之间应该联合考虑，寻求最优化 3.资源管理面临的挑战UUDN的资源分配时基于用户和APG的，而不是像传统的蜂窝网那样基于蜂窝单元和AP，另外，越来越多的应用和需求需要更多的带宽和不同的QoS要求 4.干扰管理面临的挑战 超密集环境造成了更多的干扰源，使得干扰模型变得很复杂 减小干扰和增加资源利用率是相互矛盾的，需要权衡 传统的衡量网络干扰的参数可能不能用了全面的衡量UUDN的网络 需要建立新的干扰模型来分析无线传输情境 UUDN的结构和技术UUDN的蜂窝结构和功能 三种解耦方式：1.无线接入层的用户平面和控制平面的解耦2.网络层的控制和传输解耦3.本地服务和网络服务的解耦 UUDN结构 从上图结构中可以看出，从用户角度看，没有物理或者逻辑上的蜂窝单元。某个区域的接入点会智能地自组织满足用户的移动需求和传输数据需求。 功能实体 LSC: the local service center 本地服务中心LDC： local data center 本地数据中心NSC：the network service center网络服务中心NDC： network data center 网络数据中心 LSC和LDC是提供逻辑上的控制层和用户层的解耦 NDC和NSC是提供控制和传输功能 每个实体的功能和接口1.AP：是用户终端的数据平面和控制平面的无线接入信道，包含RF、PHY、MAC、和IP层的功能，或者基于回程容量把它们组合起来2.LSC：控制服务中心，组织APG服务某一个用户，添加了一些新的功能，如：用户中心无线资源管理、有效的QoS控制、用户中心移动管理、本地无线连接控制3.LDC：提供UUDN的用户层面。提供高层的处理和动态AP信道处理，也提供用户的多AP协作和多无线电承载的收敛的功能4.NSC：提供用户控制功能、认证、授权、计费、漫游NSC之间切换功能5.NDC：传输数据的网关 UUDN和传统蜂窝网之间的协作方式1.宏蜂窝基站发挥控制层面的功能，UUDN发挥数据层面的功能2.LSC和LDC部署为宏蜂窝的基站，这样使得宏蜂窝和UUDN之间的关系更紧密 UUDDN的核心功能：动态APG方法用户的移动性是未来网络考虑的一种重要因素，所以UUDN每个用户都有一个独一无二的动态APG（DAPGing），APG环境被存储在LSC中。 动态APG主要工作过程： APG Initiating：当一个用户连接到网络，NSC根据的无线网络环境生成一个独有的APG，并且由LSC维持。 APG Member Refreshing：当一个APG建立以后，APG成员会根据用户的移动自动更新。 APG Handover：当一个用户超出当前LSC的范围，APG会切换到到属于不同NSC的LSC。 APG Deletion：当用户从UUDN断开连接时，APG将会被删除 UUDN的移动性管理传统蜂窝网是用户在移动中切换蜂窝小区，但是在UUDN结构中，网络是跟随用户移动的，DAPGing使得用户的移动管理成为可能。 对于LSC内部或者LSC之间的移动性：通过改变APG成员，终端和AP之间的无线连接可以从一个AP移动到另一个,APG的ID不变。 对于NSC之间的移动性：NSC之内APG-ID是独一无二的，当终端移动到一个新的NSC中，终端会获得一个新的APG-ID，AP成员也会重新认证。 在UUDN中，如果没有数据传输时，终端将会进入空闲模式来节省电，当有用户请求服务时，有两种方法唤醒：1.终端定期检测它是否超出AP成员的覆范围，如果超出，终端向网络更新它的位置2.终端定期发送导频信号给网络，让网络更新它的位置 资源管理与干扰控制联合优化 资源管理的两种方式：1.当有足够的资源和终端的支持时，资源分配可能是完全分布式的，否则，引入协商模式。干扰评估模型应添加到协商计划以及环境感知。2.网络端提供一个中央控制，本地控制单元生成一个可用资源池，AP通过周期性广播或专用请求来更新信息，一旦有传输需求，APG将会从资源池中选择一个合适的资源。这需要实时有效地采集本地资源情况。 安全性 UUDN将会为所有的用户终端和APG成员提供一种新的安全认证的方法 在APG更新的时候，UUDN应该应用一种灵活的认证机制 UUDN的密钥认证机制将会被加强 UUDN安全模型的选择应该在通信质量和认证效率之间权衡 总结本文是在UDN的基础上提出的UUDN，实现网络服务用户的思想，文中详尽讨论了UUDN的一些问题，对UUDN的结构、管理方式和安全认证方面有了认识。这是5G的一项技术，值得关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[西游]]></title>
      <url>%2F2017%2F%E8%A5%BF%E6%B8%B8.html</url>
      <content type="text"><![CDATA[虽然网上很多人吐槽西游伏妖篇很烂，今天还是去看了下，发现也没有想象中的那么不堪。 虽然感觉讲的东西有点乱，打了好几个妖怪，还没明白它讲的主旨电影就结束了。但是当你回味其中某些片段的时候，还是有些意思的。 前面讲唐僧虐待猴子的时候，看到这感觉这部影片应该是像《悟空传》一样讲一个不一样的猴子的情史、反抗史。 后来沙悟净说师傅心里一直有个人，每当唐僧想起她时都会一个人刻石像，当时着实被月夜下唐僧刻佛像画面所感动，三藏的专情、痛苦，他仍忘不了当初的段小姐。 电影里说，“世上最难过的关，是情关”。 忘不了，放不下，一直在心里。却终究得不到。 其实，影片里我觉得最可怜的就是小善了，她只想过一个简单人的生活，但她却凄惨一生，没有得到爱情。 最后小善临死前说：我觉得自己好傻，明明知道没有，还要问。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mobile Cloud Sensing, Big Data, and 5G Networks Make an Intelligent and Smart World]]></title>
      <url>%2F2017%2FMobile%20Cloud%20Sensing%2C%20Big%20Data%2C%20and%205G%20Networks%20Make%20an%20Intelligent%20and%20Smart%20World.html</url>
      <content type="text"><![CDATA[author: Qilong Han, Shuang Liang, and Hongli Zhang Mobile Cloud Sensing, Big Data, and 5G Networks Make an Intelligent and Smart World移动云感知，大数据，5G智能网[TOC] 摘要本文介绍移动感知和云计算，然后结合两个概念形成移动云感知技术，以及介绍5G和大数据对移动云感知的益处。 移动云感知实例： GPS不断更新你的位置，然后返回最佳导航路径。 你的手机通过声音传感器识别比较你的声音来判断你是否感冒了，返回你附近感冒人数。 当你走进服装店时，你的手机会自动显示你挑选的衣服的顾客评价。 移动云感知组成： 移动端传感器：现在的智能手机内置了各种各样的传感器，利用这些传感器可以采集到各种数据，检测出各种情景。 云计算：然而手机也受到了内存和电池的影响，为了解决内存的限制，我们将云计算和智能手机结合起来，手机将数据提交给云中心计算，然后云中心将计算结果返回给手机端。 大数据：然而由于手机端用户数量的巨大，又带来了一个问题，云服务中心的计算能力跟不上数据积累的速度，为了解决这个问题，又引入了大数据分析的技术，来处理庞大的数据量。 5G网络：来支撑巨大的数据容量和数据请求。 移动云感知就包含了移动传感器、云计算、大数据分析这三个技术来获取、处理、预测移动感知数据。 文章架构：1.移动云感知的应用，移动云计算的分类2.移动云感知的结构及各部分简介3.移动云感知的局限性4.5G和大数据使得大规模的移动云感知成为可能 移动云感知的应用分类从预测范围角度分类： 分类 例子 个人感知 个人运动管理、日常活动记录 群体感知 社区垃圾收集、餐馆排名 生态感知 气候变化、人口流动 从用户参与角度分类可分为：伺机感知和共享型感知 应用1.健康监测：各种传感器被应用于大量手机等移动设备上，可以用于监测身体的各种指数。2.与社交网络结合：通过分析社交网络得来的数据可以判断出人的情绪变化与天气变化之间的关系。3.环境监测和控制：手机应用可以计算出平时生活中对环境保护做出的贡献，也可以根据数据分析为城市绿化提出有效的意见。 移动云感知简介 云计算特点： 高效性 可扩展性 终端多样性 感知平台1.无线传感网：每个节点都有发射器和接收器，用于和其他节点进行交互。一般用于环境或物理结构变化。特点是：体积小、价格便宜、可大规模部署。2.移动设备：智能手机设备嵌入了大量的传感器，可以飞到各种各样的检测数据，由于手机的普及，我们可以通过wifi或者蜂窝网获取大量的感知数据。3.可穿戴设备：这些设备装备的传感器是某些特定功能的传感器或者是用于通信的，如手环、手表。 数据处理 在数据传到云端之前，需要考虑两个问题： 上传带宽局限性 数据隐私性（谁能获取我的数据） 1.数据处理方式（目的是为了解决数据上传带宽的限制） 数据压缩 特征抽取 2.隐私性保障使用密码学技术进行加密，使第三方应用匿名获取你的信息，并且隔绝非法请求。 移动云感知结构1.数据感知单元 Data Sensing Unit（数据源） 物理感知：一些智能穿戴设备，如手环、智能眼镜 社交感知：社交网络，如facebook等 2.数据处理单元 Data Preprocessing Unit首先检测数据源是物理感知还是社交感知，对数据进行特征抽取，然后进行压缩、加密，防止泄露。3.网络管理单元 Network Management Unit控制进入云端的数据，网络管理单元可以优化数据的吞吐量，整合其他网络，优化网络性能。4.云数据挖掘与存储 Cloud Data Mining and Storage借助云计算的计算能力和存储能力，各种不同感知源的数据在这里汇聚和分类，存储特征抽取和数据处理的结果。5.云数据认证和服务接口 Cloud Data Authentication and Service Interfaces 数据认证：决定可以获取数据和服务的途径，可以通过加密认证或者物理的指纹认证等验证方法。 服务接口：提供一些获取数据的API接口。 移动云感知的局限性1.网络资源和接口的局限性 现在使用的有4G网络（下载速度100M/S）、WiMax和wifi，对于成千上万的手机用户来说，通信的频谱远远不能承担这么大的负荷。 移动云感知要求手机必须不间断地和云端连接，但是现有的网络基础设施并不能保证这一点。 现在手机网络协议的多样性，4G网络并不能很好地兼容这些网络，需要新的通信技术来解决这个问题。2.处理云端巨大的缓存数据处理激增的巨大数据量是优化移动云的关键任务。 5G和大数据的引入5G作为移动云感知的基础支撑技术5G采用全IP模型，可以同时传输各种不同类型的数据，支持各种不同类型的网络接口，解决了上面说的手机网络协议多样性带来的问题，使得获取各种不同的移动设备的数据成为可能。另外，5G网络的速度可以超过1Gb/s，可以适应大量数据的上传，解决了网络带宽不够的问题。 将大数据应用于移动云感知将大数据应用于移动云感知是为了解决从移动端传来的大量的数据的处理和数据管理问题。 数据容量：随着智能手机的普及，移动端产生的数据呈爆炸式增长。 速度：移动数据的产生比以前快了很多。 多样性：大数据能够支持各种形式的数据，如传感器数据、音频、视频等。 价值性：将大数据和数据挖掘和机器学习的技术结合，可以发掘出数据中的潜在价值，对于预测和提高决策很有帮助。 总结感想文章阐述了移动云感知技术和大数据、5G的只是及其之间的关系，结构层次很清晰，个部分之间的关系阐述的很明了。通过本文让我认识到了现在各个新兴技术之间相互交叉的应用，而且对移动云感知这个方向有了一定的认识。同时，本文的叙述结构值得学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基础]]></title>
      <url>%2F2017%2Fjavascript%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[[TOC] 前言 NaN表示不是一个数字enter code here* 小记1.consol.log();在控制台打印输出括号里的内容 数据类型所有数据类型声明都是用var，不需要像C语言那样加数据类型，自动识别数据类型。 字符串 stringvar a = &quot;This is a strings&quot;; 布尔值 boolvar myBool = true; 数字 numbervar pi = 3.14; undefined变量存在但是未被赋值或者 读取一个不存在的对象属性时变量的类型不确定，逻辑判断是相当于false null表示值已被定义了，但是它不属于任何一种合法的类型，逻辑判断是相当于false (1.typeof()：查看变量的类型 (2.字符串拼接：string1+strign2 (3.类型转换：parseInt()将字符串转化为整形值， parseFloat()将字符串转化为浮点型 类型转换 (1.数字转字符串 num.toString(); 括号内可以填数字表示转化成几进制，不填默认是十进制 (2.字符串转数字 Number(str) 解析str得到整数或者实数 parseInt(str) 解析str得到整数 parseFloat(str) 解析str得到整数或者实 字符串操作.length12word = "hello world";word.length // 结果是11 charAt得到字符串中某个字符12word = "hello world";word.charAt(0) // 结果是h indexOf字符在字符串中的位置12word = "hello world";word.indexOf('e') // 结果是1 substring截取字符串截取字符串12word = "hello world";word.substring(0,3) // 结果是hello replace替换字符string.replace(‘被替换字符’,’替换后的字符’) split 分割字符串string.split(‘分割的标志’) 得到的结果是个数组，可以放到变量里然后去出 数组定义var arry1=[];var myarry=[‘hello’, 100, 1, 5, 25, 10]; 属性push添加数组string.push(要添加的内容1,要添加的内容2)把药添加的内容加到数组最后 unshift往数组头加元素string.unshift() 把元素加到数组头 删除数组元素pop shift splice delete 删除数组最后一个元素：string.pop();本身返回的是删除掉的元素的值 删除数组开头第一个元素：string.shift();本身返回的是删除掉的元素的值 删除数组内具体某元素：delete string[2]; 但是它不会影响元素数量，只是把那个元素变成undefined 彻底删除某个元素：string.splice(元素索引) 本身返回的是被删除的元素两个数组合并concatstring1.concat(string2)返回的是合并后的结果 if判断语句if(a==b){} 仅测试操作数的数值是否相等，而不关心操作数的类型if(a===b){} 操作数的值和类型都相等才为真 123456if() &#123;&#125;else if() &#123;&#125;else&#123;&#125; switch语句1234567switch(条件)&#123; case 条件1： 语句1；break； case 条件2： 语句2；break； case 条件1： 语句3；break； default: 语句；break；&#125; 循环语句while123while(条件)&#123;语句；&#125; for循环语句1234for (var i=0;i&lt;10;i++)&#123; 语句;&#125; 函数 定义函数function functionName(参数1，参数2…){} 函数表达式、匿名函数var functionName = function (参数1，参数2){} 对象property（属性） method（方法） 注： 对象里面的属性可以是任何类型的数据：数字、字符串、数组等 对象中属性的类型可以用typeof取出来，方法类型是’function’ 访问对象属性方法： 对象名.属性名 对象名[‘属性名’]创建对象 单独设置属性 123var objName_my = &#123;&#125;;objName_my.namemy=&apos;wang&apos;;或者 objName_my[&apos;namemy&apos;]=&apos;wang&apos;;objName_my.agemy=23; 方式二： 12345var objName = &#123;namemy:&apos;wang&apos;,agemy:23,family:[&apos;父亲&apos;,&apos;母亲&apos;]&#125;; 删除对象属性delete 对象名.属性名； 给对象添加方法对象名.functionNamemy = function (参数1，参数2){//方法体中的this表示对象functionNamemy本身函数内容;}; //注意结尾加上分号 用for输出对象内属性12345var i;for(i in objName)&#123;console.log(i);&#125; DOM 文档对象注意： 元素 = 标签（H1 P…） + 文本内容 DOM树document作为文档的root根，元素（标签）作为结点，构成一颗树，有父节点、兄弟节点。 获取DOM元素 (1). document.getElementById(‘元素的id’)这样获得整个元素标签 (2). document.getElementsByTagName(‘标签名’)返回的结果是所有相关的标签元素，是个数组对象，如getElementsByTagName(‘li’)返回所有li标签的内容 (3). document.querySelector(‘CSS选择器’) CSS选择器可以是“类名+标签”返回的是查找到的第一个元素例：document.querySelector(‘.content li’) (4).document.querySelectorAll(‘CSS选择器’)返回的是查找到的所有的元素 获取DOM节点注：假设将获取到的元素赋值给变量pagemy(1. pagemy.nodeName用于获取该元素标签属性 如果是段落返回的是p(2. pagemy.innerText 返回的是元素的文字内容(3. pagemy.parentNode 返回的是父节点的元素(4. pagemy.previousElementSibling返回的是前面一个兄弟节点的元素 pagemy.nextElementSibling返回的是前面一个兄弟节点的元素(5.pagemy.childNodes返回的是所有的子节点元素，包含元素类型的节点和文本类型的节点(6. pagemy.firstElementChild 返回的是第一个子节点元素pagemy.lastElementChild 返回的是最后一个子节点元素 创建DOM新节点(1.创建节点： .creatElement创建元素类型新节点：var newMenber_my=document.creatElement(‘li’); .creatTextNode创建文本类型节点:var newTextnode_my=document.creatElement(‘这是文本内容！’);(2. .appendChild：被添加的元素a.appendChild(要添加的元素b) 1234DOM结构&lt;a&gt; &lt;b&gt;&lt;/b&gt;&lt;/a&gt; 例：newMenber_my.appendChild(newTextnode_my); .insertBefore(插入的元素,被插入的地方) 作用是将插入的元素放到被插入地方的上面 事件onmouseoveronclickonmouseoutwindow.onload=function(){}//在页面图片等都加载完了触发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Semantic UI]]></title>
      <url>%2F2017%2FSemantic%20UI.html</url>
      <content type="text"><![CDATA[[TOC] 前言 Semantic UI 学习：http://www.semantic-ui-cn.com/learn.php Semantic UI中文网：http://www.semantic-ui-cn.com/ Semantic UI中文官方文档：http://www.semantic-ui.cn/introduction/getting-started.html Semantic UI 概述 官方网站说semantic UI需要安装node.js环境，是为了使用npm更新semantic。其实可以不用安装，直接下载zip文件就行了。 替换semantic.css内的谷歌字体CDN，把 fonts.googleeapis.com 换成 fonts.lug.ustc.edu.cn（中科大加速）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap]]></title>
      <url>%2F2017%2Fbootstrap.html</url>
      <content type="text"><![CDATA[[TOC] 前言 bootstrap3用12栏的栅格，bootstrap2用 三屏不同显示添加类：.visibel-phone visibel-tablet visibel-desktop Bootstrap CSS 概览响应式图像1&lt;img src="..." class="img-responsive" alt="响应式图像"&gt; 通过添加 img-responsive class 可以让 Bootstrap 3 中的图像对响应式布局的支持更友好。 12345.img-responsive &#123; display: inline-block; height: auto; max-width: 100%;&#125; 列表样式 参见 http://www.runoob.com/bootstrap/bootstrap-typography.html Bootstrap 引用代码&lt;code&gt;、&lt;pre&gt;请确保当您使用 &lt;pre&gt; 和 &lt;code&gt; 标签时，开始和结束标签使用了 unicode 变体：&amp;lt; 和&amp;gt;。 bootstrap表格 表单参考： http://www.runoob.com/bootstrap/bootstrap-forms.html Bootstrap 输入框组参考：http://www.runoob.com/bootstrap/bootstrap-input-groups.html 12345678910111213141516171819&lt;div style="padding: 100px 100px 10px;"&gt; &lt;form class="bs-example bs-example-form" role="form"&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;@&lt;/span&gt; &lt;input type="text" class="form-control" placeholder="twitterhandle"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control"&gt; &lt;span class="input-group-addon"&gt;.00&lt;/span&gt; &lt;/div&gt; &lt;br&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;$&lt;/span&gt; &lt;input type="text" class="form-control"&gt; &lt;span class="input-group-addon"&gt;.00&lt;/span&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 导航栏12345678910//小屏幕实现菜单折叠 &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt;//折叠按钮,#bs-example-navbar-collapse-1是下面导航的id &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt;//按钮的三条横线 &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left" role="search"&gt;//中间的搜索框 &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端库]]></title>
      <url>%2F2017%2F%E5%89%8D%E7%AB%AF%E5%BA%93.html</url>
      <content type="text"><![CDATA[[TOC] 1 12月份30个轻量的 JavaScript 库和插件http://www.yyyweb.com/4485.html 2 sweetalert推荐网址： http://t4t5.github.io/sweetalert/ sweetalert for bootstrap：http://lipis.github.io/bootstrap-sweetalert/ sweetalert的CDN网址：http://www.bootcdn.cn/sweetalert/或https://www.staticfile.org/搜索 推荐博客： confirm窗体带回调函数的例子 SweetAlert2 使用教程 3 一个简单的HTML5媒体播放器：Plyr 示例： https://plyr.io/使用文档：https://github.com/selz/plyr (一些参数设置) 引入：&lt;script src=&quot;path/to/plyr.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/plyr.css&quot;&gt;CDN(2.0.11) :https://cdnjs.cloudflare.com/ajax/libs/plyr/2.0.11/plyr.csshttps://cdnjs.cloudflare.com/ajax/libs/plyr/2.0.11/plyr.jshttps://cdnjs.cloudflare.com/ajax/libs/plyr/2.0.11/plyr.svg HTML5 Video 123456&lt;video poster="/path/to/poster.jpg" controls&gt; //封面 &lt;source src="/path/to/video.mp4" type="video/mp4"&gt; &lt;source src="/path/to/video.webm" type="video/webm"&gt; &lt;!-- Captions are optional --&gt; &lt;track kind="captions" label="English captions" src="/path/to/captions.vtt" srclang="en" default&gt;&lt;/video&gt; HTML5 Audio 1234&lt;audio controls&gt; &lt;source src="/path/to/audio.mp3" type="audio/mp3"&gt; &lt;source src="/path/to/audio.ogg" type="audio/ogg"&gt;&lt;/audio&gt; 4 Loud Links鼠标点击链接发出声音文档教程：https://github.com/mahdif/loud-links/ 5 slick图片轮播官网：http://kenwheeler.github.io/slick/ 【未完待续】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html5和bootstrap]]></title>
      <url>%2F2017%2Fhtml5%E5%92%8Cbootstrap.html</url>
      <content type="text"><![CDATA[Outline [TOC] 1.前言 bootstrap中外文档：http://v3.bootcss.com/css/ bootstrap2.3.2：http://getbootstrap.com/2.3.2/ bootstrap的twitter：http://getbootstrap.com/ http://www.runoob.com/ 2.bootstrap代码获取2.1 CDN形式：1234567891011&lt;!-- 新 Bootstrap 核心 CSS 文件 --&gt;&lt;link href="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;!-- 可选的Bootstrap主题文件（一般不使用） --&gt;&lt;script src="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap-theme.min.css"&gt;&lt;/script&gt;&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src="http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt; 此外，你还可以使用以下的 CDN 服务： 国内推荐使用 : https://www.staticfile.org/ 国际推荐使用：https://cdnjs.com/ 2.2 到官网下载源码到bootstrap的git官网进入customize进行定制，把需要的功能勾选，然后下载。 3 兼容性 为了确保适当的绘制和触屏缩放，需要在 &lt;head&gt; 之中添加 viewport 元数据标签。 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 user-scalable=no 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。 1&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt; Normalize.css为了增强跨浏览器表现的一致性，我们使用了 Normalize.css，这是由 Nicolas Gallagher 和 Jonathan Neal 维护的一个CSS 重置样式库。 123456How to use normalize.cssFirst, install or download normalize.css from GitHub. There are then 2 main ways to make use of it.Approach 1: use normalize.css as a starting point for your own project’s base CSS, customising the values to match the design’s requirements.Approach 2: include normalize.css untouched and build upon it, overriding the defaults later in your CSS if necessary. 4 布局容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。 4.1 栅格系统Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding） &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;表示占4列* 超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px) 中等屏幕 桌面显示器 (≥992px) 大屏幕 大桌面显示器 (≥1200px) 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 12&lt;div class="col-md-8"&gt;.col-md-8&lt;/div&gt;&lt;div class="col-xs-12 col-md-8"&gt;.col-xs-12 .col-md-8&lt;/div&gt; 5 常用的JS模块5.1 tooltip工具提示 5.2 popover弹出框 【未完待续】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github个人博客改域名]]></title>
      <url>%2F2017%2Fgithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%B9%E5%9F%9F%E5%90%8D.html</url>
      <content type="text"><![CDATA[感觉用github自带的域名太长了，而且有时候感觉解析太慢，就换了个自己的域名。我是在万网买的域名，没多少钱吧，下面是教程： 到万网解析域名： 上面两个IP是github官方给的，通用。你也可以ping一下自己的xxx.github.io地址获取ip。 在根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：qiuncheng.com（注意前面不添加http://） 然后就hexo d -g部署到服务器上，在还没解析好的这段时间好像访问不了博客，不要方，大概等一段时间，就能用新域名访问了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转】利用git解决hexo博客多PC间同步问题]]></title>
      <url>%2F2017%2F%E5%88%A9%E7%94%A8git%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E5%A4%9APC%E9%97%B4%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[场景 单位和家里两PC，同时都想更新blog。而由于hexo没有后台，而且全部文件都在本地生成，所以如果公司电脑上发表了A文章后回家又写了篇B文章，在家里上传后你会发现只有B文章而A文章没了（因为家里的PC上没有A文章的md文件），所以多台电脑同时用来写文章的时候，需要解决备份问题。而常用的备份方案无非两种： 百度云，Dropbox等网盘云备份（不清楚Dropbox，仅以百度云为例） 优点：免费且操作简单 不足： 备份后同步比较麻烦，每次另一台电脑上都需要手动下载备份文件夹手动覆盖。开启云端自动备份的时候，写blog的过程中如果保存了文件，会触发百度云的上传，而上传过程中产生的xxx.cfg文件会让hexo解析失败，导致hexo s生成的本地服务器进程停止，不方便边写边预览因此此方案作废 利用第三方的git服务备份 优点：部署完成后更新方便，hexo 更新完后只需要再更新全站到git即可 缺点：部署过程相对比较麻烦，对新手不友好（其实是由于对git的理解不深导致的）国内外现在知名的git服务提供商主要有：github、gitcafe、bitbucket、oschina、coding等 由于blog文件夹里有些插件配置文件会涉及比较敏感的隐私数据（云服务商的appsecret key之类的），所以建议放私有仓库（当然也可以把配置文件单独拿出来然后其余的全部扔到git的公众仓库，这个看人，本文重点也不在于git服务商的选择或者公有私有库之争）上面提及的5家服务商里，github、gitcafe的私有库是收费的，而另外三家的私有库目前免费。各位可以自行选择，我个人选择了oschina 配置过程 git多网站多账户部署过程可以参考git多网站ssh部署方案 1. 上传blog到git这个操作建议在blog进度最新的PC上进行的，否则后面解决冲突会比较麻烦在osc上添加公钥，建立新respo等过程略过不讲。 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件 有些插件或者主题是git上下过来安装的话，每个文件夹下都会有对应的.git 文件夹，记得先删掉，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。##.git文件夹被删除后整个文件对应的git仓库状态也会被清空##).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public /_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去初始化仓库blog根目录下执行以下代码：12git initgit remote add origin &lt;server&gt; 是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端 添加本地文件到仓库并同步到git上 123git add . #添加blog目录下所有文件，注意有个`.`（`.gitignore`声明过的文件不包含在内)git commit -m "first commit" #添加更新说明git push -u origin master #推送更新到云端服务器 在执行这步之前一定要注意检查下.gitignore文件的内容，看看是否正确的把一些文件夹忽略掉了。如果加错了的话可以用 1git rm -r --cached . 撤销添加操作。 到这里的时候，云端备份已经完成 2. 将git的内容同步到本地假设之前将A电脑里的内容备份到git了，现在B电脑准备同步内容。1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。这步不可以跳过git fetch --allgit reset --hard origin/master fetch是将云端所有内容拉取下来。reset则是不做任何合并处理，强制将本地内容指向刚刚同步下来的云端内容（正常pull的话需要考虑不少冲突的问题，比较麻烦。） 3. 更新文章后的同步操作假设在B电脑上写完了文章，也hexo d -g发布完了，这时候需要将新文章的md文件更新上去。（其实就是提交更新给git，会的可以无视了）同一个bash界面下：1git add . 这时候可以用git status查看状态，一般会显示刚刚更改过的文件状态。如：12345On branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: db.json new file: source/_posts/test.md 上面的输出状态即说明’db.json’文件做了更改，source/_posts目录下新增了’test.md’文件。 然后对更改添加说明并推送到远程仓库.12git commit -m '更新信息'git push 当显示类似如下提示的时候，即表示备份成功12To git@git.oschina.net:xxxx/blog-backup.git + 2c77e1e...5616bc6 master -&gt; master (forced update) 再到A电脑上的时候，只需要1git pull 即可同步更新 给git配置sock5代理由于某些众所周知的缘故，所以github时不时的有时候速度会很慢，这种情况下本地代理就派上用场了。这里以给git的SSH传输方式配置本地SS代理为例说下配置过程： 打开~/.ssh/config文件。在Host github *.github.com下添加以下字段：1Proxycommand ssh -S 127.0.0.1:1080 %h %p 测试连接保存退出后重启git bash。输入ssh -vT git@github.com，当返回Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.的时候即说明配置成功之后github的所有流量都会走本地的ss代理。 本文转自Chitanda Akari]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++的运算重载符]]></title>
      <url>%2F2017%2FC%2B%2B%E7%9A%84%E8%BF%90%E7%AE%97%E9%87%8D%E8%BD%BD%E7%AC%A6.html</url>
      <content type="text"><![CDATA[C++的多态笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++的继承]]></title>
      <url>%2F2017%2FC%2B%2B%E7%9A%84%E7%BB%A7%E6%89%BF.html</url>
      <content type="text"><![CDATA[C++的继承笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++的函数模板]]></title>
      <url>%2F2017%2FC%2B%2B%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF.html</url>
      <content type="text"><![CDATA[C++的函数模板]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++的静态]]></title>
      <url>%2F2017%2FC%2B%2B%E7%9A%84%E9%9D%99%E6%80%81.html</url>
      <content type="text"><![CDATA[C++的静态 1.静态成员不依赖于对象产生，没有声明对象，它也能赋值2.普通成员函数默认传入this指针，但是静态成员函数不传入，所以静态成员函数不能调用普通的成员，能调用静态的数据成员。3.sizeof去求对象的大小，结果是不包含静态的数据成员的4.静态数据成员类似于PHP中的全局变量，可以用来记录某个数据5.静态函数不能加const修饰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[概率论与随机过程]]></title>
      <url>%2F2017%2F%E6%A6%82%E7%8E%87%E8%AE%BA.html</url>
      <content type="text"><![CDATA[《概率论与随机过程》手写笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++的多态]]></title>
      <url>%2F2017%2FC%2B%2B%E7%9A%84%E5%A4%9A%E6%80%81.html</url>
      <content type="text"><![CDATA[C++的多态笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++类和对象]]></title>
      <url>%2F2016%2FC%2B%2B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[Private和protected数据在main函数中是不能直接利用属性访问的，只能通过类的对象函数访问。无论是构造函数还是拷贝构造函数、友员函数，都要在类体里声明。 1.构造函数： 构造函数作用是接收传过来的实参，对类的对象属性进行赋值，也可以不传参。 利用构造函数声明创建一个类的对象，myclass s(1,2); 构造函数的名字和类的名字必须相同：写在类外myclass::myclass(int i,intj);写在类里myclass(int i,intj)； 2.拷贝构造函数： 用一个已经存在的对象来创建并初始化一个新的对象，在拷贝构造函数里能通过在传来的对象值上做运算给新对象的属性值赋值。 形式：在类外myclass::myclass(myclass &amp;p);以下三种情况会调用拷贝构造函数： 用类的对象去创建初始化一个新对象：point p2(p1); 函数形参是类的对象：f(p2);//在执行f()函数之前调用拷贝构造函数 函数返回值是类的对象：p2=g();//g()返回的是一个对象,返回时执行 3.友员 友员函数是不属于类的属性的，它是能调用多个对象属性值，并作运算。 除了友员函数外，只有类的对象函数能调用私有属性。 友员成员： 类girl友员成员函数prt()为类boy的友员函数，就必须先定义类girl。在类boy声明友员函数时要加：：12345friend void girl：：prt（boy &amp;）； girl g("Amily",15);Boy b("Tim",16);ｇ．ｐｒｔ(b);//调用 友员类：当一个类声明为另一个类的友员类时，这个类的所有成员函数都成为另一个类的友员函数 friend girl； 利用友员函数求两点之间距离代码：++12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std; class point&#123; double x,y; public: point(double a=0,double b=0) &#123; x=a; y=b; &#125; point(point &amp;p)&#123; x=p.x-0.1; y=p.y-0.1; &#125; double getx()&#123; return x; &#125; double gety()&#123; return y; &#125; friend double dist(point &amp;p1,point &amp;p2);&#125;;double dist(point &amp;p1,point &amp;p2)&#123; return (sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)));&#125; int main() &#123; point p1(1.1,2.1); point p2(p1); std::cout &lt;&lt; "两点之间距离是"&lt;&lt;dist(p1,p2) &lt;&lt; std::endl; return 0;&#125; 不用友员函数求两点之间距离 代码：++1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std; class point&#123; double x,y; public: double dist(point &amp;p1,point &amp;p2); point(double a=0,double b=0) &#123; x=a; y=b; &#125; point(point &amp;p)&#123; x=p.x-0.1; y=p.y-0.1; &#125; double getx()&#123; return x; &#125; double gety()&#123; return y; &#125; // friend double dist(point &amp;p1,point &amp;p2);&#125;;double point::dist(point &amp;p1,point &amp;p2)&#123; return (sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)));&#125; int main() &#123; point p1(1.1,2.1); point p2(p1); std::cout &lt;&lt; "两点之间距离是"&lt;&lt;p1.dist(p1,p2) &lt;&lt; std::endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[巧妙用PHP修改文件中变量的内容]]></title>
      <url>%2F2016%2F%E5%B7%A7%E5%A6%99%E7%94%A8PHP%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AE%B9.html</url>
      <content type="text"><![CDATA[在php中如果有个内容你不想用数据库存，存在变量内，但是你又想通过在页面中能修改它的值，可以用以下的办法： 先建立一个备份文件，用来做字符串查找的原文12345678910&lt;?php//文件config_default.phpsession_start();define('TEE_SITE_URL', 'https://teegon.com/');define('TEE_API_URL', 'https://api.teegon.com/');//TEE_CLIENT_ID TEE_CLIENT_SECRET$GLOBALS['_tiangong']['alipay']['domain']='[tiangong_value_domain]';$GLOBALS['_tiangong']['alipay']['id']='[tiangong_value_id]';$GLOBALS['_tiangong']['alipay']['key']='[tiangong_value_key]';?&gt; 下面是欲修改的文件内容：123456789&lt;?phpsession_start();define('TEE_SITE_URL', 'https://teegon.com/');define('TEE_API_URL', 'https://api.teegon.com/');//TEE_CLIENT_ID TEE_CLIENT_SECRET$GLOBALS['_tiangong']['defaul']['domain']='http://faka.xiaoqyun.com.cn';$GLOBALS['_tiangong']['defaul']['id']='rti6y7oqtvyms5lqpqlbjf2d';$GLOBALS['_tiangong']['defaul']['key']='rgyyaucihzbmgrjgf6ax6r57wy3rx6wn';?&gt; 正题来了，修改步骤如下： (1)读取config_default.php文件内容，存到一个变量内； (2)通过字符串替换将该变量内的相应想修改的内容替换掉，甚至变量名都可以改写； (3)关键步骤到了，将修改后的变量的内容写到config.php中。OK，完事了，省去了读取数据库的麻烦。12345678910&lt;?php//$_POST['tiangong_id']、$_POST['tiangong_key']是从页面获取过来的if(!empty($_POST['tiangong_id']) &amp;&amp; !empty($_POST['tiangong_key']))&#123; $file=file_get_contents(dirname(dirname(__FILE__)) . "/pay/tiangong/config_default.php"); $file=str_replace("[tiangong_value_id]",$_POST['tiangong_id'],$file);//str_replace(find，replace，搜索范围) $file=str_replace("[tiangong_value_key]",$_POST['tiangong_key'],$file); $file=str_replace("[tiangong_value_domain]",$_POST['tiangong_domain'],$file); $file=str_replace("alipay","defaul",$file); file_put_contents(dirname(dirname(__FILE__)) . "/pay/tiangong/config.php",$file);&#125; 上面的代码是摘自我写的一个支付接口的网站。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生活]]></title>
      <url>%2F2016%2F%E7%94%9F%E6%B4%BB.html</url>
      <content type="text"><![CDATA[感觉最惬意的一刻就是午后坐在实验室 午后的阳光照进窗台，上上网，看看书，做着感兴趣的事，静谧，安逸 每天做自己该做的事看书，打打羽毛球，努力学习接触有意思的人和事 生活莫过于此。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL5.7.9免安装版配置方法+修改默认密码]]></title>
      <url>%2F2016%2FMySQL5-7-9%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81.html</url>
      <content type="text"><![CDATA[1. 解压MySQL压缩包 将下载的MySQL压缩包解压到自定义目录下,我的解压目录是: “D:\Program Files\mysql-5.7.9-win32” 将解压目录下默认文件 my-default.ini 拷贝一份，改名 my.ini。并新建一个data空文件夹 复制下面的配置信息到 my.ini 保存:1234567port=3306 basedir=D:\dev\mysql\mysql-5.7.9-winx64 datadir=D:\dev\mysql\mysql-5.7.9-winx64\data max_connections=200character-set-server=utf8 default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 2.将DOS指向mysql目录下的bin文件夹，输入服务安装命令：123mysqld --consolemysqld --initializemysqld install 安装成功后会提示服务安装成功。 3.启动和关闭mysql：启动服务命令为：net start mysql关闭服务命令为：net stop mysql 4.修改mysql默认密码： （1）清空data文件夹然后我们就通过敲命令生成一个data文件，并把mysql的默认密码显示出来： 1命令：mysqld --initialize --user=mysql --console 可以看到图上的最后一行的最后一个字段是mysql的默认密码 （2）接下来我们就先用这个默认密码登录到mysql里面，当然前提是要先start mysql；1命令：net start mysql 正常情况会提示你启动成功，（注意：有的会报无法启动3534，这是因为目录下面没有data文件，这个时候你要先用第一条命令init一下）； （3）接着第二条命令，我们登录mysql：1命令：mysql -uroot -p 会提示你输入密码，就是上面我们看到的默认密码，输入后正常情况下会有welcome等提示 （4）到这里我们就可以开始去修改我们的默认密码了，接着输入：1命令：use mysql 然后会提示你：1ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. （5）不要急，我们接着输入命令：1命令：alter user 'root'@'localhost' identified by 'mysql'; 然后会提示你Query OK ! （6）下面就正式进行修改我们的密码1SET PASSWORD = PASSWORD('yourPwd'); PASSWORD 后面写你刚刚设置过的新密码； 这次我们可以flush了：1flush privileges; 然后exit：1exit 这样我们就成功设置我们的新密码了。 好了，我们来验证一下，我是继续在开出的cmd命令窗口输入：1mysql -uroot -p 然后输入密码 （你的新密码），正常情况下就OK了。 后来发现直接用msi安装包安装更方便，sb了，想想还是留下这篇文章吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github发布文章方法]]></title>
      <url>%2F2016%2Fgithub%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E6%96%B9%E6%B3%95.html</url>
      <content type="text"><![CDATA[在gitbash发指令:1hexo n 标题名字 然后用下面指令部署到git仓库;1hexo d -g]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[禁止右键菜单代码、禁止复制粘贴代码]]></title>
      <url>%2F2016%2F%E7%A6%81%E6%AD%A2%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E4%BB%A3%E7%A0%81%E3%80%81%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E4%BB%A3%E7%A0%81.html</url>
      <content type="text"><![CDATA[代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script type="text/javascript"&gt;//屏蔽右键菜单document.oncontextmenu = function (event)&#123;if(window.event)&#123;event = window.event;&#125;try&#123;var the = event.srcElement;if (!((the.tagName == "INPUT" &amp;&amp; the.type.toLowerCase() == "text") || the.tagName == "TEXTAREA"))&#123;return false;&#125;return true;&#125;catch (e)&#123;return false;&#125;&#125;//屏蔽粘贴document.onpaste = function (event)&#123;if(window.event)&#123;event = window.event;&#125;try&#123;var the = event.srcElement;if (!((the.tagName == "INPUT" &amp;&amp; the.type.toLowerCase() == "text") || the.tagName == "TEXTAREA"))&#123;return false;&#125;return true;&#125;catch (e)&#123;return false;&#125;&#125;//屏蔽复制document.oncopy = function (event)&#123;if(window.event)&#123;event = window.event;&#125;try&#123;var the = event.srcElement;if(!((the.tagName == "INPUT" &amp;&amp; the.type.toLowerCase() == "text") || the.tagName == "TEXTAREA"))&#123;return false;&#125;return true;&#125;catch (e)&#123;return false;&#125;&#125;//屏蔽剪切document.oncut = function (event)&#123;if(window.event)&#123;event = window.event;&#125;try&#123;var the = event.srcElement;if(!((the.tagName == "INPUT" &amp;&amp; the.type.toLowerCase() == "text") || the.tagName == "TEXTAREA"))&#123;return false;&#125;return true;&#125;catch (e)&#123;return false;&#125;&#125;//屏蔽选中document.onselectstart = function (event)&#123;if(window.event)&#123;event = window.event;&#125;try&#123;var the = event.srcElement;if (!((the.tagName == "INPUT" &amp;&amp; the.type.toLowerCase() == "text") || the.tagName == "TEXTAREA"))&#123;return false;&#125;return true;&#125; catch (e) &#123;return false;&#125;&#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这十二行代码是如何让浏览器爆炸的（可以整蛊下你的好友）]]></title>
      <url>%2F2016%2F%E8%BF%99%E5%8D%81%E4%BA%8C%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%88%86%E7%82%B8%E7%9A%84%EF%BC%88%E5%8F%AF%E4%BB%A5%E6%95%B4%E8%9B%8A%E4%B8%8B%E4%BD%A0%E7%9A%84%E5%A5%BD%E5%8F%8B%EF%BC%89.html</url>
      <content type="text"><![CDATA[完整HTML代码如下：12345678910&lt;html&gt;&lt;body&gt; &lt;script&gt; var total=""; for (var i=0;i&lt;1000000;i++)&#123; total= total+i.toString(); history.pushState(0,0,total);&#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; demo：（温馨提示：请保存浏览器其它窗口的编辑任务）接来下会发生什么？点开以后，我的状态是这样的：如果你是PC端用户，点开链接以后，电脑CPU内存极有可能一路狂飙直至浏览器崩溃卡死！如果你是移动端（安卓、iPhone）用户，点开链接以后你的浏览器会闪退！在微博、微信客户端点开链接同样会闪退。至于在推文中提到的让iPhone重启，这一现象倒是没有出现。22：49 修正：iPhone用Safari打开之后链接之后，手机注销重启了！…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地没安装git-shell情况下上传报错解决方法]]></title>
      <url>%2F2016%2F%E6%9C%AC%E5%9C%B0%E6%B2%A1%E5%AE%89%E8%A3%85git-shell%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
      <content type="text"><![CDATA[把跟目录下的站点配置文件对应更改成下面的代码：1234deploy: type: git repository: ssh://git@github.com/wanghansong/wanghansong.github.io branch: master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git搭建博客小记]]></title>
      <url>%2F2016%2Fgit%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0.html</url>
      <content type="text"><![CDATA[因为我电脑是windows的，所以下面是windows搭建方法 1.安装Node.js2.安装git for windows 安装好后，打开cmd，输入下面命令，看下是否正常1node -v npm -v 正常的话会回复版本号 3.安装hexo 输入全局安装命令：1npm install -g hexo 4.在C盘（或其他）根目录下创建文件夹Hexo。在C:/Hexo文件夹内右键选择Git bash。然后在类似DOS的界面内输入以下命令：1hexo init 接着输入下面命令安装依赖包1npm install 5.本地查看执行以下命令，然后到浏览器输入ocalhost:4000看看。12hexo generatehexo server 6.申请Github帐号并创建仓库repository这步网上有很多,我参考这篇 7.设置SSH 第一步：生成钥匙和锁 在命令行输入：ssh-keygen -t rsa -C your_email@youremail.com 然后回车，期间会问你生成的文件名和passphrase，对于我这种菜鸟，我一路点回车。如果你也是菜鸟，跟我一样做。 （passphrase 可以设置密码） 第二步：将锁放到github的帐户里 上一步生成的文件放在了C:/Users/用户名（你的windows用户）/.ssh/文件夹中，用记事本打开其中的id_rsa.pub文件，全部内容复制。登录github网站，找到account setting,将刚才复制的粘贴到key文本框中。 第三步：测试是否成功 在命令行输入：1ssh -T git@github.com 如果成功，会显示欢迎字符。 8.修改 Hexo 中的 _config.yml 文件照这样改：1234deploy: type: git repository: ssh://git@github.com/wanghansong/wanghansong.github.io branch: master 9.修改模版感觉官方原始的模版很丑,于是就用了NEXT的模版。HEXO也有很多模版 10.将本地的站点部署到网上输入如下命令行1hexo d -g 然后到你网站wanghansong.github.io查看。OK 小记：12345hexo g == hexo generate生成文件 hexo d == hexo deploy部署 hexo s == hexo server开本地站点 hexo n == hexo new新建文章hexo d -g==保存文件并部署]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2Fhello-world.html</url>
      <content type="text"><![CDATA[欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#117;&#115;&#x74;&#x67;&#x6f;&#99;&#107;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。]]></content>
    </entry>

    
  
  
</search>
